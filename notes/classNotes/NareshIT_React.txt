?/07
=====

Features of React:
1. It uses "Virtual DOM".
	- It is a copy of actual DOM in memory.
	- Application update the virtual DOM and later commits with actual DOM.
	- It makes the rendering appear faster than normal. 

2. It is component based.
	- It enables easy reusability.
	- Easy to extend
	- Make loosely coupled and extensible.
	- Easy to test 

3. Modular Approach 
	- It uses only what is required for application.
	- Application specific framework or library.
	- It makes application light weight and faster.

4. Server Side Rendering with Framework like Next JS
	- Components can pre-render on server.
	- This makes server side interactions faster.

Issues with React:
1. It is not designed for what you are using.
2. Hence lot of GAP's.
3. You need lot of 3rd party plugins. 
4. Pace of development is very fast.
5. No proper documentation. 


Using React in existing web application:

1. Download and Install  Node JS on your PC

2. Download and Install Visual Studio Code Editor

3. Install Live Server plugin for VS code

4. Create a new project folder

		D:\web-app

5. Open in VS code

6. Create the file system for traditional web application

	> npm  init  -y			[ package.json ]

		D:\web-app
		|
		|_package.json
		|_public
		|_src
		|_readme.md

7. Add pages 

		index.html		// at root level
		home.html		// in public folder

8. React up to version 18x provides a legacy library to import and use in page.
	- React requires 3 basic libraries
		a) react
		b) react-dom
		c) babel
	- "react" is a core library that provides access to all react services.
	- "react-dom" is virtual DOM library.
	- "babel" is a JavaScript compiler used for React.

Note: You can use CDN links from official sources. 
	  You can also download using package managers.

Version 17x & 18x:

	- Visit  "https://legacy.reactjs.org/"
	- Go to "doc" [documentation]
	- Select CDN links
	- Copy CDN for production or development 

			react.development.js
			react-dom.development.js		=> add to your home page

	- Visit "https://babeljs.io/"
	- Go to "docs"
	- Go to "Integration Packages"
	- Select "@babel/standalone"
	- Copy CDN and paste into your page.

Ex:
1. index.html

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>Welcome to Web App</h1>
    React is working in <a href="./public/home.html"> Home page</a>.
</body>
</html>

2. home.html

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Page</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script type="text/babel">
        /* 17x
         ReactDOM.render("Welcome to React JS", document.getElementById("root"));
         */
         var root = ReactDOM.createRoot(document.getElementById("root"));
         root.render("Hello ! React 18");
    </script>
</head>
<body>
    <noscript>Please enable JavaScript on your browser.</noscript>
    <div id="root"></div>
</body>
</html>

?/07
=====

React in Existing Application [ React 18 ]
	- react
	- react-dom
	- babel

React up to 17x version:

	ReactDOM.render("Element|Markup", document.getElementById("root"));

React 18x version:

	const  root = ReactDOM.createRoot(document.getElementById("root"));
	root.render("Element | Markup");


Note: ReactDOM is a base for creating "Virtual DOM".

Download Libraries:

1. Open terminal in your project

2. Run the following commands

		> npm  install  react@18   react-dom@18   @babel/standalone  --save

3. All library files are copied into "node_modules".

4. Link the following files to your HTML page

   <script  src="../node_modules/react/umd/react.development.js"> </script>
   <script  src="../node_modules/react-dom/umd/react-dom.development.js"> </script>
   <script  src="../node_modules/@babel/standalone/babel.js"> </script>

Note: React uses JavaScript XML [ JSX ] as language. 
	  JSX can't be translated using JavaScript interpreter in browser.
	  Hence your script for React requires the MIME type as:

		a) text/jsx
		b) text/babel

	<script type="text/jsx  or text/babel">
	</script>

Ex:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Page</title>
    <script src="../node_modules/react/umd/react.development.js"></script>
    <script src="../node_modules/react-dom/umd/react-dom.development.js"></script>
    <script src="../node_modules/@babel/standalone/babel.js"></script>
    <script type="text/babel">
        const root = ReactDOM.createRoot(document.getElementById("root"));
        root.render("Welcome to React 18");
    </script>
</head>
<body>
    <noscript>Please enable JavaScript on your browser.</noscript>
    <div id="root"></div>
</body>
</html>
		
					  React Components
- React is component based.
- Components enable easy reusability and extensibility. 
- A component comprises of 3 basic elements

	1. Presentation		[with HTML]
	2. Styles				[with CSS]
	3. Logic				[with JSX or TSX]

- React components are designed by using function or class. 
- Class components are still supported by React but not recommended in new code.

Function Components:

1. You can configure a function using declaration or expression. 

	Declaration:
		function Name()
		{
		}

	Expression:
		const Name = function(){ 

		}
2. Every component function name must start with uppercase letter.
3. Component function can't be void type.
4. Component function must always return a JSX element. 
Syntax:
		function  Login()
		{
		   return (<JSX></JSX>);
		}

5. Component function must return only one fragment. 

		function Login()
		{
		  return (
			      <h3>User Login </h3>		=> invalid
			      <p> Welcome </p>
			     );
		}


		function Login()
		{
		  return (
			     <div>
					... your content..		=> valid
			     </div>
			    )
		 }

6. JSX function component can't have elements with void syntax.
    Every element must have an end token. 
	
		<img> </img>		=> valid
		<img />			=> valid
		<img>			=> invalid
		<input type="text" />

7. JSX element can't have attributes, you have to configure only properties.

		<img class="" />		invalid
		<img className="" />	valid

8. Components are accessed and rendered as JSX elements

		function Login()
		{
		  render (<JSX></JSX>);
		}

		root.render(<Login> </Login>);
		root.render(<Login />);

Ex:
home.html

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Page</title>
    <style>
        nav {
            display: flex;
            justify-content: space-between;
            border:1px solid gray;
            padding: 20px;
        }
    </style>
    <script src="../node_modules/react/umd/react.development.js"></script>
    <script src="../node_modules/react-dom/umd/react-dom.development.js"></script>
    <script src="../node_modules/@babel/standalone/babel.js"></script>
    <script type="text/babel">

        function Login()
        {
            return(
                <div>
                    <h2>User Login</h2>
                    <dl>
                     <dt>User Name </dt>
                     <dd><input type="text" /></dd>    
                     <dt>Password </dt> 
                     <dd><input type="password" /></dd>
                    </dl>
                    <button>Login</button>
                </div>
            )
        }

        function SearchBar(){
            return(
                <div>
                    <input type="text" placeholder="Search Amazon.in" />
                    <button>Search</button>
                </div>
            )
        }
        function NavBar(){
            return(
                <nav>
                <span>Amazon </span>
                <SearchBar />
                <span>Home</span>
                <span>About</span>
                <span>Contact</span>
                </nav>
            )
        }

        const root = ReactDOM.createRoot(document.getElementById("root"));
        root.render(
             <div>
                <NavBar/>
                <Login />
             </div>
            );
    </script>
</head>
<body>
    <noscript>Please enable JavaScript on your browser.</noscript>
    <div id="root"></div>
</body>
</html>



21/07
======

React Components
- Function Components
- JSX Rules

					Creating a new React SPA

- You can create a new web application manually or by using any bundling tool. 
- The popular bundling tools for Web are:
	 - Webpack
	 - Parcel
	 - Vite etc.

- Bundling tools provide a scaffold approach where application is configured and file system is designed according to developer requirements. 

Create React App with Vite: 

1. Open any location on your PC where you want to create react app.

2. Run the command [ from command prompt ]

		E:\> npm  create  vite@latest   app_name  -- --  template  react

    Note: The default language for "react" template is JavaScript.
	
		> Framework		:  React
		> Variant 			: JavaScript 

3. Change into project folder and run the command 

		E:\app_name> npm  install

     It will install all dependencies required for project.

4. Open project folder in VS code

5. You can view the following file system


	File / Folder		Description
	------------------------------------------------------------------------------------------------------
	node_modules 	comprises of all library files installed for project.

	public			comprises of all static resources like, html, images etc.

	src				comprises of all dynamic resources like .js, .jsx, .ts, .css, .scss..

	.gitignore			configures the resources to ignore while publishing to GIT.

	eslint.config.js		It is JavaScript language configuration & analysis tool. 

	index.html		It is the startup page for project.

	package.json		]  comprises of application meta data, you can configure
	package-lock.json	]  scripts, commands, versions etc.


	Readme.md		It is a help document by developers for developers. 

	vite.config.js		It is bundler configuration to plugin various external libraries
					or frameworks required for application.

6. Run application using the following command

	> npm  run dev			[for development]


    Application starts on local server   "http://localhost:5173/".

    You can request from browser.

React High Level Flow:
1. You can request react application from browser 

		http://localhost:5173

2. Browser uses the event "DOMContentLoaded", which loads static DOM of "Index.html".

3. Index page loads  "main.jsx", which is entry point for react application. 

4. "src/main.jsx" is create a virtual DOM and renders "App" component, which is the default component created for your application. 

	createRoot(document.getElementById("root")).render(
	   <React.Strict>
		<App />
	  </React.Strict>

	Note:  Alias of React.Strict is  <StrictMode>

Creating a custom component:

- Every component in development environment comprises of 3 files

	a) component.jsx		comprises of markup and logic
	b) component.css		comprises of styles
	c) component.test.jsx	comprises test cases used for testing component

- Create a new folder "components" and keep in "src".

- Add a folder by name "login" into components with files

		login.jsx
		login.css

- login.jsx   code

	export  function Login()
	{
	   return(
		   <>
			... your design ...
		   </>
		);
	}

- Go to "main.jsx" and import login 

	import  { Login } from  "../component/login/login.jsx";

	<StrictMode>
		<Login />
	</StrictMode>


?/07
=====

Creating React Application using Vite Bundler 
File System in React JavaScript Template
Execution Flow - High Level

	index.html => main.jsx => create virtual DOM => render "app" component

Note: You have to import CSS file into JSX component in order to use the styles.
	  It is always recommended not to use type selector for element styles, until you
	  want same across all components.

Syntax:
		login.jsx
		
		import  './login.css';

Enable bootstrap for React application:

1. Install bootstrap and icons for application

	> npm  install  bootstrap   bootstrap-icons --save

2. Go to main.jsx  and import following files 

	import '../node_modules/bootstrap/dist/css/bootstrap.css';
	import '../node_modules/bootstrap-icons/font/bootstrap-icons.css';

3. You can use icons and bootstrap classes

	<div className='bi bi-person-circle'> User Login </div>

	<input type="text"  className='form-control' />


Ex:
1. Add a new folder into  src/components  by name  "Netflix"

2. Add following component files into Netflix folder

		netflix-index.jsx
		netflix-header.jsx
		netflix-section.jsx
		netflix-main.jsx

		netflix-index.css
		netflix-section.css

3. Go to main.jsx and setup Netflix Index as startup 

	<StrictMode>
	   <NetflixIndex />
	</StrictMode>


netflix-index.css 

.banner {
    background-image: url("/public/netflix-banner.jpg");
    background-size: cover;
    height: 100vh;
}
.shade {
    background-color: rgba(0,0,0,0.7);
    height: 100vh;
}

netflix-index.jsx

import './netflix-index.css';
import { NetflixHeader } from './netflix-header';
import { NetflixSection } from './netflix-section';

export function NetflixIndex(){
    return(
        <div className="banner">
          <div className='shade'>
              <NetflixHeader />
              <NetflixSection />
          </div>
        </div>
    )
}

netflix-header.jsx


export function NetflixHeader(){
    return(
        <header className="d-flex justify-content-between p-4">
            <div className="h1 text-danger fw-bold">
                NETFLIX
            </div>
            <div className="d-flex align-items-center justify-content-center">
                <div>
                    <div className="input-group">
                   <span className="bi bi-translate input-group-text"></span> 
                   <select className="form-select">
                      <option>Language</option>
                   </select>
                    </div>
                </div>
                <button className="btn btn-danger mx-4">Sign In</button>
            </div>
        </header>
    )
}

netflix-section.css 

.section {
    padding-top: 50px;
    font-family: Arial;
}
.section-title {
    font-size: 60px;
    font-weight: bold;
}
.section-subtitle {
    font-size: 25px;
}

netflix-section.jsx

import { NetflixMain } from './netflix-main';
import './netflix-section.css';

export function NetflixSection(){
    return(
        <section className="text-white section text-center mt-4">
           <div className="section-title"> Unlimited movies, TV <br/> shows and more </div>
           <div className="section-subtitle"> Starts at ₹149. Cancel at any time. </div>
           <NetflixMain />
        </section>
    )
}

netflix-main.jsx



export function NetflixMain(){
    return(
        <main>
            <p>Ready to watch? Enter your email to create or restart your membership.</p>
            <div className="d-flex justify-content-center">
                <div className="mt-3">
                    <div className="input-group input-group-lg">
                    <input type="email" className="form-control mx-2" placeholder="Your email address" />
                    <button className="btn btn-danger"> Get Started <span className="bi bi-chevron-right"></span> </button>
                    </div>
                </div>
            </div>
        </main>
    )
}

					 Data Binding & State in Component
- Data Binding is the process of accessing data from source and binding to UI elements.
- It also includes identifying changes in data and update back to the source. 
		
		
		Fetching from source and bind to UI		=> One Way Binding
		Identify changes in UI and update back	=> Two Way Binding

- React implicitly supports only "One Way Binding".
- You have to explicitly configure "Two Way Binding". 
- React uses "{ }" as data binding expression. 

Syntax:
		var uname = "John";

		<p> Hello !  {uname} </p>

		<input type="text"  value={uname}  />

- You can bind dynamic values into a string along with JavaScript binding expression 
  "${ }". However it is supported only for string enclosed in backtick. 

Syntax:
		var bgstyle = "bg-danger";

		<p className={`text-white text-center ${bgstyle}`}>

		<p  className={ "text-white text-center " + bgstyle }>



23/07
======

Components Hierarchy 
Data Binding
One Way Binding
Binding Expressing { }   ${ } [backtick]

						    Component State

- Web application uses "http / https" as protocol.
- They are state less protocols. 
- They can't remember information between requests. 
- Hence various state management techniques are required. 
- It is always recommended to use a state for configuring data in a component. 
- Variables are immutable hence it is not recommended to handle data with variables. 
- State is mutable and there are various techniques in React 
		useState()
		useReducer()
		useContext()
		useRef()
		useMemo()
		useCallback()
		Local Storage
		Session Storage
		Cookies 
		Redux etc..

Component Local State:
 - Every React component is configured with a local state.
 - It is created while creating component. 
 - A component is create when you request the component.
 - It is destroyed automatically when you move from one component to another. 
 - It can be used across multiple requests of component, but can't be used across 
   components. 
 - React provides "useState()" hook to access and use the local state. 

FAQ: What is a hook in React?
Ans:   Hook is a service. It is a predefined business logic.
	  You can access, customize and implement according to requirements. 
	  It must be configured at high level in a component. 
	  You can't define inside any another block. 

useState() Hook:
 - It is a React hook used for accessing component local state.
 - It allows to access and use the local state with any type of data
		a) Primitive
		b) Non Primitive 
 - It requires a reference for accessing and initializing value into memory
		a) getter 	[ to access value ]
		b) setter	[ to initialize value] 

 - It returns a getter and setter, which you have to access using de-structure technique. 

Syntax:
		const  [getter, setter] = useState(value);

		{ getter }				// to access

		setter(newValue)		// to initialize new value 

		setter = value;			// invalid

FAQ's:
1. Can we use var and let to configure state?
A. Yes. But not recommended. 

2. Why developers prefer using "const" for state?
A. State must be initialized and should not allow assignment. 
    Hence "const" is good for state, as it will not allow assignment and require initialization.

3. If you use const, then how you will assign a new value into state?
A. We don't assign values into state, we reinitialize memory for storing a new value.


Component Mount Phase:
- A component is created when user requests the component. 
- State is configured while creating component. 
- You can initialize values into state while creating but can't reinitialize directly in 
  component.
- It requires a mount phase or any element event to reinitialize new values. 
- Component mount is configured by using "useEffect()" hook.

Syntax:
		useEffect(()=>{
		
			// actions to perform on mount

		},[ dependencies ]);

- Every component mounts only once, you can mount again by configuring the dependencies. 
- A component mounts again when ever the dependency detects a change.

Ex:
data-binding.jsx

import { useEffect, useState } from "react"

export function DataBinding(){
    
    const [price, setPrice] = useState(0);
    const [name, setName] = useState('');
    
    useEffect(()=>{
        setPrice(40500);
        setName('Samsung TV');
    },[]);

    return(
        <div className="container-fluid">
            <h2 className={`text-center text-warning p-3`}>Data Binding</h2>
            <dl>
                <dt>Product Name</dt>
                <dd>{name}</dd>
                <dt>Price</dt>
                <dd>{price}</dd>
            </dl>
        </div>
    )
}

Binding Various Data Types:

Primitive Types:

1. Number

	const [price] = useState(45000);

	- You can use all JavaScript number functions to handle numbers

		a) toFixed()
		b) toPrecision()
		c) toLocaleString()	 => regional language, style : currency, unit, precent 
		d) parseInt()
		e) parseFloat()
		f) isNaN()

Ex:
import { useEffect, useState } from "react"

export function DataBinding(){
    
    const [price, setPrice] = useState(0);
    const [views] = useState(5600009);
    
    useEffect(()=>{
        setPrice(405000);
    },[]);

    return(
        <div className="container-fluid">
            <h2 className={`text-center text-warning p-3`}>Data Binding</h2>
            <dl>
                <dt>Price</dt>
                <dd>{price.toLocaleString('en-in', { style:'currency', currency:'INR'})}</dd>
                <dt>Views</dt>
                <dd>{views.toLocaleString('en-us', {notation:'compact'})}</dd>
            </dl>
        </div>
    )
}


24/07
======

- useState()
- useEffect()

1. Number

2. String
	" "
	'  '
	` `  ${ }

3. Boolean 
	- Boolean handles true or false as keywords.
	- JSX can't print boolean keywords.
	- It can't use decision making statements.
	- Hence you have to handle using operators and functions. 

Syntax:
	 const [stock] = useState(true);

	 {  (stock===true) ? 'true' : 'false' }

4. Undefined 

	- It specifies that value is not defined at compile time. 
	- It uses "undefined" keyword. 

Syntax:
	  const [price , setPrice]  = useState();

	  { (price) ? price : 'price not defined' }


5. Null

	- Null is a keyword returned when value is not provided at runtime of application.
	- It is verified by using null keyword.

Syntax:
	  const [price] = useState(prompt("Enter Price"));

	  {  (price===null) ? 'Not defined' : price }
 
Note: React application compiles and executes 2 times. One for development and
	  another for production, you can remove the <StrictMode> to execute only
	  for development.

Non Primitive Types:

1. Array
	- All array methods are same in React.
	- Configuration same as JavaScript.
	- To present array elements always use the implicit iterator functions.
		a) map()
		b) forEach()

	- React Fiber from react 19 recommends all async techniques.
	- Hence you have to use "map()" as iterator for reading elements.
	- JSX can dynamically create any element and append to page.
	- Every repeating element must have a unique "key".

Syntax:
	const [cities] = useState([ 'Delhi' , 'Hyd' ])


	<ol>
	  {
	    cities.map((city, index)=> <li key={index}> { city } </li>)
	  }

Ex:
data-binding.jsx

import { useEffect, useState } from "react"

export function DataBinding(){
    
    const [categories] = useState(['All','Electronics', 'Fashion','Footwear']);
    
    useEffect(()=>{
        
    },[]);

    return(
        <div className="container-fluid">
            <header className="mt-4 p-4 d-flex justify-content-between border border-2">
                <div className="h3">Amazon</div>
                <nav>
                    {
                        categories.map((category, i)=> <span className="mx-4" key={i}><a href="#">{category}</a></span> )
                    }
                </nav>
                <div>
                    <span className="bi bi-heart"></span>
                    <span className="bi bi-cart3 mx-2"></span>
                </div>
            </header>
            <ol>
                {
                    categories.map((category,index)=><li key={index}>{category}</li>)
                }
            </ol>
            <select>
                {
                    categories.map((category, index)=><option key={index}>{category}</option>)
                }
            </select>
        </div>
    )
}

2. Object Type
	
	- Object is key and value collection. 
	- You can access the value with reference of key.
	- All object manipulations are same as in JavaScript.
		a) Object.keys()	returns all keys
		b) delete			removes a key
		c) in 			verifies key
		d) typeof			returns value type
		etc.

Ex:
data-binding.jsx

import { useEffect, useState } from "react"

export function DataBinding(){
    
    const [product] = useState({Name:'Samsung TV', Price: 45000, ShippedTo:['Delhi', 'Hyd'], Rating:{Rate:4.2, Count:600}});
    
    useEffect(()=>{
        
    },[]);

    return(
        <div className="container-fluid">
            <h2>Product Details</h2>
            <dl>
                <dt>Name</dt>
                <dd>{product.Name}</dd>
                <dt>Price</dt>
                <dd>{product.Price}</dd>
                <dt>Shipped To</dt>
                <dd>
                    <ul>
                        {
                            product.ShippedTo.map(city=><li key={city}>{city}</li>)
                        }
                    </ul>
                </dd>
                <dt>Rating</dt>
                <dd>
                    {product.Rating.Rate} <span className="bi bi-star-fill text-success"></span> [{product.Rating.Count}]
                </dd>
            </dl>
        </div>
    )
}

Ex: Array of objects

data-binding.jsx

import { useEffect, useState } from "react"

export function DataBinding(){
    
    const [products] = useState([
         {Name: 'Samsung TV', Price: 45000},
         {Name: 'Mobile', Price: 23000},
         {Name: 'Nike Casuals', Price: 2560}
    ]);
    
    useEffect(()=>{
        
    },[]);

    return(
        <div className="container-fluid">
            <h2>Products Table</h2>
            <table className="table table-hover">
                <thead>
                    <tr>
                        <th>Name</th>
                        <th>Price</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody>
                    {
                        products.map((product,index)=><tr key={index}><td>{product.Name}</td><td>{product.Price}</td><td> <button className="btn btn-warning bi bi-pen-fill"></button> <button className="btn btn-danger bi bi-trash mx-2"></button> </td></tr>)
                    }
                </tbody>
            </table>
        </div>
    )
}


Ex: Nested Map

data-binding.jsx

import { useEffect, useState } from "react"

export function DataBinding(){
    
    const [data] = useState([
        {Category: 'Electronics', Products: ['Televisions', 'Mobiles']},
        {Category: 'Fashion', Products: ['Footwear', 'Jeans']}
    ])
    
    useEffect(()=>{
        
    },[]);

    return(
        <div className="container-fluid">
            <h2>Products</h2>
            <ol>
                {
                    data.map(item=>
                        <li key={item}>
                            {item.Category}
                            <ul>
                                {
                                    item.Products.map(product=><li key={product}>{product}</li>)
                                }
                            </ul>
                        </li>
                    )
                }
            </ol>
            <select>
                {
                    data.map(item=>
                    <optgroup key={item} label={item.Category}>
                        {
                            item.Products.map(product=><option key={product}>{product}</option>)
                        }
                    </optgroup>)
                }
            </select>
        </div>
    )
}


25/07
=======

Bind Data 
- map()
- key

Handling Date Type:
- JavaScript date type is configured using "Date()" constructor. 
- JavaScript uses a new dynamic memory to allocate date and time values.
- However React will not allow creating objects as React child.
- Hence you have to configure date using constructor without "new" operator. 

Syntax:
	  const  [dept] =  useState(Date());

- React will not allow to present date by using date functions of JavaScript like
	    toLocaleDateString()
	    toDateString()
	    toLocaleTimeString()
	    toTimeString()
	    etc..

- React requires 3rd party date libraries to manipulate date and time values
	a) moment
	b) dayjs
	c) luxon  etc.

Setup Moment:

1. Install moment for React

		> npm  install  moment --save

2. Import moment into component

		import   moment  from  "moment";

3. Apply format

	 const  [dept] = useState(Date());

	 {  moment(dept).format( 'string format' )  }

	 Date String Format:
	
			dddd		weekday name
			DD			date number
			MM			month number
			MMM		short month format
			MMMM		long month format
			yyyy			full year

Ex:
	       { moment(dept).format('dddd DD, MMMM yyyy) }


Regular Expression Type:
 - Regular expression is enclosed in "/  /".
 - It comprises of meta characters and quantifiers. 
 - It uses match() method to compare with a value. 

Ex:
data-binding.jsx

import { useEffect, useState } from "react";
import moment from "moment";

export function DataBinding(){
    
    const [mobile, setMobile] = useState('');
    
    useEffect(()=>{
        setMobile('+919876543210');
    },[]);

    return(
        <div className="container-fluid">
           <h2>Data Binding</h2>
           { (mobile.match(/\+91\d{10}/))?'Verified':'Invalid Mobile' }
        </div>
    )
}

			     React AJAX techniques for fetching data from API

- React can use JavaScript AJAX methods like
	a) XMLHttpRequest
	b) fetch() 

XMLHttpRequest:
 - It is the native browser object to make Ajax call from browser. 
 - It is default synchronous, you have to explicitly make it async. 
 - It returns only Text and XML response.
 - It requires explicit parsing methods for other data type.
 - It is not good in exceptions. 
 - It is not good in handling security. [ CORS, XSS, XSRF ]

Syntax:
 1. Create XMLHttpRequest object

	 var http = new XMLHttpRequest();

 2. Configure the request

	 http.open("method", "url", async:boolean);
	 http.send();

3. Execute the request

	http.onreadystatechange = function(){

	}

4. On Ready get the response 

	if (http.readyState === 4)
	{
		// http.responseText 
	}

Ex:
1. public/product.json

{
    "title": "Apple iPhone 16 (Pink, 256 GB)",
    "price": 79900,
    "image": "iphone-pink.jpg",
    "rating": {"rate":4.6, "ratings": 19560, "reviews": 5602},
    "offers": [
        "Bank Offer5% cashback on Flipkart Axis Bank Credit Card upto ₹4,000 per statement quarter",
        "Bank Offer5% cashback on Axis Bank Flipkart Debit Card up to ₹750",
        "Bank OfferFlat ₹10 Instant Cashback on Paytm UPI Trxns. Min Order Value ₹500. Valid once per Paytm account",
        "Special PriceGet extra ₹5000 off (price inclusive of cashback/coupon)"
    ]
}

2. component/databinding

	data-binding.jsx

import { useEffect, useState } from "react";

export function DataBinding(){
    
    const [product, setProduct] = useState({title:'', price:0, image:'', rating:{rate:0, ratings:0, reviews:0}, offers:[]});
    
    function GetProduct(){

         var http = new XMLHttpRequest();
         http.open("get","product.json",true);
         http.send();

         http.onreadystatechange = function(){

               if(http.readyState===4){
                    setProduct(JSON.parse(http.responseText));
               }

         }

    }


    useEffect(()=>{
        GetProduct();
    },[]);

    return(
        <div className="container-fluid">
            <div className="row mt-5">
                <div className="col-3">
                    <img src={product.image} width="100%" />
                </div>
                <div className="col-9">
                    <div className="fs-4">{product.title}</div>
                    <div className="mt-2">
                        <span className="badge bg-success rounded"> {product.rating.rate} <span className="bi bi-star-fill"></span> </span>
                        <span className="mx-4 fw-bold text-secondary"> {product.rating.ratings.toLocaleString()} ratings & {product.rating.reviews.toLocaleString()} reviews </span>
                    </div>
                    <div className="mt-3">
                        <div className="h1">{product.price.toLocaleString('en-in', { style:"currency", currency:"INR", minimumFractionDigits:0 })}</div>
                    </div>
                    <div className="mt-3">
                        <h5>Available Offers</h5>
                        <ul className="list-unstyled">
                            {
                                product.offers.map(offer=><li className="bi my-3 text-success bi-tag-fill" key={offer}> <span className="text-secondary">{offer}</span> </li>)
                            }
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    )
}

Fetch Promise: 
 - It is JavaScript promise. 
 - Promise is by default async.
 - It returns the response in binary format. 
 - It requires explicit conversions. 
 - It is not good in security.

Syntax:
	
      fetch("url")
		.then(function(response){  convert to json })
		.then(function(data){  })
		.catch(function(error){ })
		.finally(function(){ })

Ex:
 data-binding.jsx

import { useEffect, useState } from "react";

export function DataBinding(){
    
    const [product, setProduct] = useState({title:'', price:0, image:'', rating:{rate:0, ratings:0, reviews:0}, offers:[]});
    
    function GetProduct(){

          fetch('product.json')
          .then(response=> response.json())
          .then(product=>{
              setProduct(product);
          })

    }


    useEffect(()=>{
        GetProduct();
    },[]);

    return(
        <div className="container-fluid">
            <div className="row mt-5">
                <div className="col-3">
                    <img src={product.image} width="100%" />
                </div>
                <div className="col-9">
                    <div className="fs-4">{product.title}</div>
                    <div className="mt-2">
                        <span className="badge bg-success rounded"> {product.rating.rate} <span className="bi bi-star-fill"></span> </span>
                        <span className="mx-4 fw-bold text-secondary"> {product.rating.ratings.toLocaleString()} ratings & {product.rating.reviews.toLocaleString()} reviews </span>
                    </div>
                    <div className="mt-3">
                        <div className="h1">{product.price.toLocaleString('en-in', { style:"currency", currency:"INR", minimumFractionDigits:0 })}</div>
                    </div>
                    <div className="mt-3">
                        <h5>Available Offers</h5>
                        <ul className="list-unstyled">
                            {
                                product.offers.map(offer=><li className="bi my-3 text-success bi-tag-fill" key={offer}> <span className="text-secondary">{offer}</span> </li>)
                            }
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    )
}


28/07
======

3rd Party Services for API requests: Axios

- It is asynchronous.
- It returns data directly in the native format of its source. 
- Explicit conversions not required. 
- It is good in handling exceptions. 
- It returns various status codes. 
- It can cancel requests. 
- It is good in security, supports CORS, XSS, XSRF handling. 
     		CORS	- Cross Origin Resource Sharing
		XSS		- Cross Site Scripting Attacks
		XSRF	- Cross Site Request Forgery 
- It supports handling multiple requests simultaneously at the same time.


1. Install axios for project

	> npm  install  axios --save

2. Import axios into component

	import   axios  from  "axios";

3. Make axios request

	axios.get()
	axios.post()
	axios.put()	
	axios.delete() etc.

Syntax:
	 axios.get("url").then().catch().finally()

	then()		: It is a callback on resolve comprises of a response object with
				  various details like
					a) data
					b) statusCode
					c) statusText
					d) header etc.

Syntax:
	axios.get(url)
		 .then(function(response){
 			response.data;
			response.status;
			response.statusText;
			response.headers;
		})
		.catch(function(error){
			// returns error object
		})
		.finally(function(){
			// always 
		})

Ex:
1. public/product.json

{
    "title": "Apple iPhone 16 (Pink, 256 GB)",
    "price": 79900,
    "image": "iphone-pink.jpg",
    "rating": {"rate":4.6, "ratings": 19560, "reviews": 5602},
    "offers": [
        "Bank Offer5% cashback on Flipkart Axis Bank Credit Card upto ₹4,000 per statement quarter",
        "Bank Offer5% cashback on Axis Bank Flipkart Debit Card up to ₹750",
        "Bank OfferFlat ₹10 Instant Cashback on Paytm UPI Trxns. Min Order Value ₹500. Valid once per Paytm account",
        "Special PriceGet extra ₹5000 off (price inclusive of cashback/coupon)"
    ]
}

2. data-binding.jsx

import axios from "axios";
import { useEffect, useState } from "react";

export function DataBinding(){
    
    const [product, setProduct] = useState({title:'', price:0, image:'', rating:{rate:0, ratings:0, reviews:0}, offers:[]});
    
    function GetProduct(){

         axios.get('product.json').then(response=>{
              setProduct(response.data);
         })

    }


    useEffect(()=>{
        GetProduct();
    },[]);

    return(
        <div className="container-fluid">
            <div className="row mt-5">
                <div className="col-3">
                    <img src={product.image} width="100%" />
                </div>
                <div className="col-9">
                    <div className="fs-4">{product.title}</div>
                    <div className="mt-2">
                        <span className="badge bg-success rounded"> {product.rating.rate} <span className="bi bi-star-fill"></span> </span>
                        <span className="mx-4 fw-bold text-secondary"> {product.rating.ratings.toLocaleString()} ratings & {product.rating.reviews.toLocaleString()} reviews </span>
                    </div>
                    <div className="mt-3">
                        <div className="h1">{product.price.toLocaleString('en-in', { style:"currency", currency:"INR", minimumFractionDigits:0 })}</div>
                    </div>
                    <div className="mt-3">
                        <h5>Available Offers</h5>
                        <ul className="list-unstyled">
                            {
                                product.offers.map(offer=><li className="bi my-3 text-success bi-tag-fill" key={offer}> <span className="text-secondary">{offer}</span> </li>)
                            }
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    )
}

						 Class Binding
- It is the process of binding CSS classes to JSX elements.
- It requires className property.

Syntax:
	  <div  className={ `text-success ${dynamic-class}` }> </div>

	  const [dynamic-class] = useState('text-center');

					       Style Binding

- It is the process of binding inline styles to JSX elements.
- It requires "style" property.
- Style uses a JavaScript object with style attribute as key and style value as value.
- Style attribute is always camel case.
- Style value is always string.

			General				React Property
			----------------------------------------------------------
			font-size				fontSize
			text-align				textAlign
			color				color
			background-color		backgroundColor
			etc..
Syntax:
	 <h1  style={ { textAlign:'center', border:'2px solid red'} }>  Text </h1>

Ex:
	const [ styleObj ]  = useState( { textAlign: 'center', color: 'red' } );

	<h1  style={ styleObj } > Text </h1>


						Event Binding
- What is Event?
- What is Event Handler?
- What is Event Listener?
- Delegate and Observer.
- Sender and Subscriber.
- Event Propagation / Bubbling  [ stopPropagation() ]
- Prevent Default  [ preventDefault() ]
- Event Arguments 
	a) Default [this, event]
	b) Custom
- Event Looping 
- Event Profiling 

FAQ: What is Event Looping?
Ans:  It is the process of executing the tasks on specific event trigger.
	 Event uses a looping order to execute the given tasks.

	 Synchronous Task => Micro Task => Asynchronous Task
					     [ Promise ]		[ Async, Await ]

<!DOCTYPE html>
<html lang="en">
<head>
     <meta charset="UTF-8">
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
     <title>Document</title>
     <script>
          function ClickMe(){
               console.log("Start Request");
               setTimeout(function(){
                    console.log("Async Task");
               },0);
               Promise.resolve().then(function(){
                    console.log("Micro Task");
               })
               console.log("End Request");
          }
     </script>
</head>
<body>
     <button onclick="ClickMe()">Click</button>
</body>
</html>
						  Event Binding
					      [Synthetic Events]


29/07
======

React Synthetic Events:
- React Virtual DOM events are derived from Synthetic Event base.
- Synthetic Events map to actual DOM events.

	onClick [ Synthetic Event ]  => onclick [ Browser Event ]


Configuring Event:
 - Event uses "Delegate" mechanism.
 - Delegate is a function pointer.
 - Event follows a software design pattern called "Observer", which is a communication
   pattern.

Syntax:
		function  handleInsertClick()
		{
		}

		<button  onClick={ handleInsertClick }> Insert </button>

Event Arguments:
 - Every event can handle payload using default and custom arguments.
 - Payload is the data carried from one location to another. 
 - Actual DOM event can handle 
	a) Default Arguments [ this, event ]
	b) Custom Arguments 

- Virtual DOM event have a default "event" argument configured for event.
- It uses listener mechanism which provides "event" with both element and event details. 

Syntax:
	  function handleInsertClick(e)
	  {
		e.clientX;
		e.clientY;
		e.keyCode;
		e.which;
		e.ctrlKey; etc.

		e.target.id
		e.target.value 
		e.target.className etc.
	 }
	 
	<button onClick= {handleInsertClick }>

Ex:
event-binding.jsx

import { useState } from "react";

export function EventBinding(){

    const [msg, setMsg] = useState(null);

    function handleInsertClick(e){
        setMsg('Inserted Successfully');
        console.log(`Button Value : ${e.target.value}\nButton Id : ${e.target.id}\nX Position : ${e.clientX}`)
    }
    return(
        <div className="container-fluid">
            <button value="Insert" id="btnInsert" onClick={handleInsertClick}>Insert</button>
            <p>{msg}</p>
        </div>
    )
}

- You can configure event to carry custom arguments along with default arguments.
- It requires a function in JSX to allocate memory on event trigger. 

Syntax:
	   <button  onClick={ (e) => handleInsertClick(e, custom_args) }>  


	    function handleInsertClick(e, ...args)
	    {
	    }

Ex:
 event-binding.jsx

import { useState } from "react";

export function EventBinding(){

    const [msg, setMsg] = useState(null);

    function handleInsertClick(e,...product){
        setMsg('Inserted Successfully');
        let [id, name, stock, cities, rating] = product;
        console.log(`Id=${id}\nName=${name}\nStock=${stock}\nCities=${cities}\nRating=${rating.Rate}`);
        console.log(`Button Value=${e.target.value}\nX Position=${e.clientX}`);
    }
    return(
        <div className="container-fluid">
            <button value="Insert" id="btnInsert" onClick={(event)=> handleInsertClick(event, 1, 'TV', true, ['Delhi', 'Hyd'], {Rate:4.2})}>Insert</button>
            <p>{msg}</p>
        </div>
    )
}

Event Propagation & Prevent Default:

- Event propagation is a bubbling mechanism where the parent event is simulated on child trigger. 
- You can stop propagation by using event method "stopPropagation()".

Syntax:
	    function handleChildClick(e)		
	    {
		e.stopPropagation();
	    }

- Every generic element have a pre-defined functionality configured.  
- It executes along with the defined functionality. 
- You can stop default functionality by using event method "preventDefault()".

Syntax:
	  function handleSubmit(e)
	  {
		e.preventDefault();
	  }
	 <form  onSubmit={handleSubmit}>
	
Ex:
 event-binding.jsx

import { useState } from "react";

export function EventBinding(){

    function NavClick(){
        alert('Navbar Clicked - Navigate to Home');
    }
    function SearchClick(e){
        e.stopPropagation();
        alert('Search Clicked - Shows search results');
    }

    function SubmitClick(e){
        e.preventDefault();
        alert('Form Submitted');
    }
    
    return(
        <div className="container-fluid">
            <nav onClick={NavClick} className="p-2 border border-2 border-dark m-4">
                <h2>Amazon</h2>
                <button onClick={SearchClick} className="btn bi bi-search btn-warning"></button>
            </nav>
            <section className="m-4">
                <form onSubmit={SubmitClick}>
                    <h3>User Name</h3>
                    <input type="text" name="User" /> <button type="submit">Login</button> 
                </form>
            </section>
        </div>
    )
}

Event for Two Way Binding:
- React enables only One-Way-Binding implicitly. 
- It will not allow changes into element value.
- You can change element value only with "onChange" event.
- Two way data binding requires new value from element, which you can configure only with "onChange".

Syntax:
	 <input type="text"  onChange={handleNameChange}>
	 <select onChange={handleCityChange}>
	 <input type="checkbox" onChange={handleCheckChange}>

Ex:
 event-binding.jsx

 import { useState } from "react";

export function EventBinding(){

    const [uname, setUname] = useState('John');
    const [msg, setMsg] = useState(null);

    function handleNameChange(e){
        setUname(e.target.value);
    }
    function VerifyName(e){
        if(e.target.value==='David'){
            setMsg('Name Taken - Try another');
        } else {
            setMsg('Name Available');
        }
    }
    
    function handleBlur(){
        setMsg('');
    }


    return(
        <div className="container-fluid">
            <dl>
                <dt>User Name</dt>
                <dd><input type="text" onBlur={handleBlur} onKeyUp={VerifyName} onChange={handleNameChange} value={uname} /></dd>
                <dd>{msg}</dd>
            </dl>
            <h2>Hello ! {uname}</h2>
        </div>
    )
}

Synthetic Events
1. Mouse event
2. Keyboard 
3. Button
4. Touch
5. Timer
6. Form


30/07
=======

React Synthetic Events Notes
============================

1. Mouse Events
---------------
- onMouseOver
- onMouseOut
- onMouseDown
- onMouseUp
- onMouseMove

Example A: Image Preview on Mouse Over
---------------------------------------

File: public/mobiles.json
--------------------------
[
  { "img_src": "m1.png" },
  { "img_src": "m2.png" },
  { "img_src": "m3.png" },
  { "img_src": "m4.png" },
  { "img_src": "m5.png" }
]

File: src/components/mouse-demo/mouse-demo.jsx
----------------------------------------------
import axios from "axios";
import { useEffect, useState } from "react";
import './mouse-demo.css';

export function MouseDemo() {
  const [mobiles, setMobiles] = useState([{ img_src: null }]);
  const [previewSrc, setPreviewSrc] = useState('m1.png');

  useEffect(() => {
    axios.get('mobiles.json').then(response => {
      setMobiles(response.data);
    });
  }, []);

  function handleMouseOver(e) {
    setPreviewSrc(e.target.src);
  }

  return (
    <div className="container-fluid">
      <div className="row mt-5">
        <div className="col-1">
          {mobiles.map(mobile => (
            <div key={mobile.img_src} className="my-4 container-style">
              <img
                onMouseOver={handleMouseOver}
                src={mobile.img_src}
                width="50px"
                height="50px"
              />
            </div>
          ))}
        </div>
        <div className="col-11">
          <img width="400" height="400" src={previewSrc} />
        </div>
      </div>
    </div>
  );
}

File: src/components/mouse-demo/mouse-demo.css
----------------------------------------------
.container-style {
  border: 2px solid gray;
  width: 50px;
}

.container-style:hover {
  border: 2px solid blue;
  cursor: grab;
}

Example B: Mouse Animation on Click
------------------------------------

File: mouse-animation.css
--------------------------
@keyframes Spin {
  from {
    transform: rotate(0deg) scale(1);
  }
  to {
    transform: rotate(360deg) scale(2);
  }
}

File: mouse-animation.jsx
--------------------------
import { useState } from "react";
import './mouse-animation.css';

export function MouseAnimation() {
  const [styleObj, setStyleObj] = useState({
    animationName: 'Spin',
    animationDuration: '5s',
    animationIterationCount: 'infinite',
    animationTimingFunction: 'linear'
  });

  function handleMouseDown() {
    setStyleObj({
      animationName: 'Spin',
      animationDuration: '1s',
      animationIterationCount: 'infinite',
      animationTimingFunction: 'linear'
    });
  }

  function handleMouseUp() {
    setStyleObj({
      animationName: 'Spin',
      animationDuration: '5s',
      animationIterationCount: 'infinite',
      animationTimingFunction: 'linear'
    });
  }

  return (
    <div className="d-flex justify-content-center align-items-center" style={{ height: '100vh' }}>
      <div>
        <img
          onMouseDown={handleMouseDown}
          onMouseUp={handleMouseUp}
          style={styleObj}
          src="react.svg"
          width="200"
          height="200"
        />
      </div>
    </div>
  );
}

Example C: Image Follows Mouse Movement
----------------------------------------

File: mouse-move.jsx
---------------------
import { useState } from "react";

export function MouseMove() {
  const [imgPosition, setImgPosition] = useState({
    position: null,
    top: null,
    left: null
  });

  function handleMouseMove(e) {
    setImgPosition({
      position: 'fixed',
      left: e.clientX + 'px',
      top: e.clientY + 'px'
    });
  }

  return (
    <div onMouseMove={handleMouseMove}>
      <div style={{ height: '1000px' }}>
        <h1>Move your mouse pointer to test</h1>
      </div>
      <img style={imgPosition} width="50" height="50" src="flag.gif" />
    </div>
  );
}

2. Keyboard Events
-------------------
- onKeyUp
- onKeyDown
- onKeyPress

Notes:
------
* onKeyUp and onKeyDown are useful for detecting key interactions.
* onKeyPress is deprecated and should be avoided in modern apps.

Example: Username Validation
----------------------------

File: keydemo.jsx
------------------
import axios from "axios";
import { useEffect, useState } from "react";

export function KeyDemo() {
  const [users, setUsers] = useState([{ user_id: null }]);
  const [msg, setMsg] = useState(null);
  const [validationClass, setValidationClass] = useState(null);

  useEffect(() => {
    axios.get('users.json').then(response => {
      setUsers(response.data);
    });
  }, []);

  function VerifyUser(e) {
    for (let user of users) {
      if (user.user_id === e.target.value) {
        setMsg('User Id Taken - Try Another');
        setValidationClass('text-danger');
        return;
      }
    }
    setMsg('User Id Available');
    setValidationClass('text-success');
  }

  return (
    <div className="container">
      <h2>Register User</h2>
      <dl>
        <dt>User Id</dt>
        <dd><input type="text" onKeyUp={VerifyUser} /></dd>
        <dd className={validationClass}>{msg}</dd>
      </dl>
    </div>
  );
}


31/07
======

React Synthetic Events Notes
============================

1. Mouse Events
---------------
- onMouseOver
- onMouseOut
- onMouseDown
- onMouseUp
- onMouseMove

Example A: Image Preview on Mouse Over
--------------------------------------

File: public/mobiles.json
--------------------------
[
  { "img_src": "m1.png" },
  { "img_src": "m2.png" },
  { "img_src": "m3.png" },
  { "img_src": "m4.png" },
  { "img_src": "m5.png" }
]

File: src/components/mouse-demo/mouse-demo.jsx
----------------------------------------------
import axios from "axios";
import { useEffect, useState } from "react";
import './mouse-demo.css';

export function MouseDemo() {
  const [mobiles, setMobiles] = useState([{ img_src: null }]);
  const [previewSrc, setPreviewSrc] = useState('m1.png');

  useEffect(() => {
    axios.get('mobiles.json').then(response => {
      setMobiles(response.data);
    });
  }, []);

  function handleMouseOver(e) {
    setPreviewSrc(e.target.src);
  }

  return (
    <div className="container-fluid">
      <div className="row mt-5">
        <div className="col-1">
          {mobiles.map(mobile => (
            <div key={mobile.img_src} className="my-4 container-style">
              <img onMouseOver={handleMouseOver} src={mobile.img_src} width="50px" height="50px" />
            </div>
          ))}
        </div>
        <div className="col-11">
          <img width="400" height="400" src={previewSrc} />
        </div>
      </div>
    </div>
  );
}

File: src/components/mouse-demo/mouse-demo.css
----------------------------------------------
.container-style {
  border: 2px solid gray;
  width: 50px;
}

.container-style:hover {
  border: 2px solid blue;
  cursor: grab;
}

Example B: Mouse Animation on Click
-----------------------------------

File: mouse-animation.css
--------------------------
@keyframes Spin {
  from {
    transform: rotate(0deg) scale(1);
  }
  to {
    transform: rotate(360deg) scale(2);
  }
}

File: mouse-animation.jsx
--------------------------
import { useState } from "react";
import './mouse-animation.css';

export function MouseAnimation() {
  const [styleObj, setStyleObj] = useState({
    animationName: 'Spin',
    animationDuration: '5s',
    animationIterationCount: 'infinite',
    animationTimingFunction: 'linear'
  });

  function handleMouseDown() {
    setStyleObj({ ...styleObj, animationDuration: '1s' });
  }

  function handleMouseUp() {
    setStyleObj({ ...styleObj, animationDuration: '5s' });
  }

  return (
    <div className="d-flex justify-content-center align-items-center" style={{ height: '100vh' }}>
      <div>
        <img onMouseDown={handleMouseDown} onMouseUp={handleMouseUp} style={styleObj} src="react.svg" width="200" height="200" />
      </div>
    </div>
  );
}

Example C: Image Follows Mouse Movement
---------------------------------------

File: mouse-move.jsx
---------------------
import { useState } from "react";

export function MouseMove() {
  const [imgPosition, setImgPosition] = useState({
    position: null,
    top: null,
    left: null
  });

  function handleMouseMove(e) {
    setImgPosition({
      position: 'fixed',
      left: e.clientX + 'px',
      top: e.clientY + 'px'
    });
  }

  return (
    <div onMouseMove={handleMouseMove}>
      <div style={{ height: '1000px' }}>
        <h1>Move your mouse pointer to test</h1>
      </div>
      <img style={imgPosition} width="50" height="50" src="flag.gif" />
    </div>
  );
}

2. Keyboard Events
-------------------
- onKeyUp
- onKeyDown
- onKeyPress

Notes:
* onKeyUp and onKeyDown are useful for detecting key interactions.
* onKeyPress is deprecated and should be avoided in modern apps.

Example: Username Validation
----------------------------

File: keydemo.jsx
------------------
import axios from "axios";
import { useEffect, useState } from "react";

export function KeyDemo() {
  const [users, setUsers] = useState([{ user_id: null }]);
  const [msg, setMsg] = useState(null);
  const [validationClass, setValidationClass] = useState(null);

  useEffect(() => {
    axios.get('users.json').then(response => {
      setUsers(response.data);
    });
  }, []);

  function VerifyUser(e) {
    for (let user of users) {
      if (user.user_id === e.target.value) {
        setMsg('User Id Taken - Try Another');
        setValidationClass('text-danger');
        return;
      }
    }
    setMsg('User Id Available');
    setValidationClass('text-success');
  }

  return (
    <div className="container">
      <h2>Register User</h2>
      <dl>
        <dt>User Id</dt>
        <dd><input type="text" onKeyUp={VerifyUser} /></dd>
        <dd className={validationClass}>{msg}</dd>
      </dl>
    </div>
  );
}

3. Element State Events
------------------------
- onChange
- onBlur
- onFocus

Example: EMI Calculator
------------------------

File: emi-calculator.jsx
-------------------------
import { useState } from "react";

export function EMICalculator() {
  const [amount, setAmount] = useState(100000);
  const [years, setYears] = useState(1);
  const [rate, setRate] = useState(10.45);
  const [emi, setEmi] = useState(0);
  const [toggleResult, setToggleResult] = useState('d-none');

  function handleAmountChange(e) {
    setAmount(e.target.value);
  }

  function handleYearsChange(e) {
    setYears(e.target.value);
  }

  function handleRateChange(e) {
    setRate(e.target.value);
  }

  function handleCalculateClick() {
    var P = parseInt(amount);
    var N = parseInt(years) * 12;
    var R = parseFloat(rate) / 12 / 100;
    var EMI = P * R * (Math.pow(1 + R, N)) / (Math.pow(1 + R, N) - 1);
    setEmi(EMI);
    setToggleResult('d-block');
  }

  return (
    <div className="container-fluid">
      <div className="p-4 border border-2 mt-4">
        <h4 className="text-center">Personal Loan EMI Calculator</h4>

        <div className="row my-4">
          <div className="col">
            Amount you need ₹ <input onChange={handleAmountChange} type="text" value={amount} size="10" />
          </div>
          <div className="col">
            for <input type="text" onChange={handleYearsChange} size="2" value={years} /> years
          </div>
          <div className="col">
            interest rate <input onChange={handleRateChange} type="text" size="4" value={rate} /> %
          </div>
        </div>

        <div className="my-4 row">
          <div className="col">
            <input type="range" onChange={handleAmountChange} value={amount} className="form-range" step="10000" min="100000" max="1000000" />
            <div>
              <span>₹ 1,00,000/-</span>
              <span className="float-end">₹ 10,00,000/-</span>
            </div>
          </div>
          <div className="col">
            <input type="range" onChange={handleYearsChange} value={years} className="form-range" min="1" max="5" />
            <div>
              <span>1 Year</span>
              <span className="float-end">5 Years</span>
            </div>
          </div>
          <div className="col">
            <input type="range" onChange={handleRateChange} value={rate} className="form-range" step="0.01" min="10.45" max="18.45" />
            <div>
              <span>10.45%</span>
              <span className="float-end">18.45%</span>
            </div>
          </div>
        </div>

        <div className="row mt-5">
          <div className="col text-end">
            <button onClick={handleCalculateClick} className="btn btn-primary">Calculate</button>
          </div>
        </div>

        <div className={`row mt-5 ${toggleResult}`}>
          <div className="col">
            <div className="text-center fs-4">
              Your EMI amount is <span className="fw-bold">
                {emi.toLocaleString('en-in', {
                  style: 'currency',
                  currency: 'INR',
                  minimumFractionDigits: 2,
                  maximumFractionDigits: 2
                })}
              </span> for next {years * 12} months.
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

4. Button Events
-----------------
- onClick
- onDoubleClick
- onContextMenu

Note:
-----
- Synthetic events can’t disable real DOM behavior directly.
- Use native DOM event listeners (like `document.oncontextmenu`) to override.

Syntax:
-------
function syntheticEvent() {
  document.onactualDOMEvent = function() {
    return false;
  };
}

Example: Button Actions
------------------------

File: button-demo.jsx
----------------------
export function ButtonDemo() {
  function handleDoubleClick() {
    window.open('m1.png', 'Mobile', 'width=400 height=400');
  }

  function handleContextMenu() {
    document.oncontextmenu = function () {
      alert('Right Click Not Allowed');
      return false;
    };
  }

  return (
    <div onContextMenu={handleContextMenu} className="container-fluid">
      <h2>Button Events</h2>
      <img onDoubleClick={handleDoubleClick} src="m1.png" width="150" height="150" />
      <p>Double Click to view large</p>
    </div>
  );
}

5. Timer Events
----------------
- setTimeout()
- clearTimeout()
- setInterval()
- clearInterval()

Debounce:
---------
- Delays execution of a task.
- Task is stored in memory using setTimeout.
- Can be cancelled using clearTimeout.
- Use useRef() to store timeout ID reference.

Syntax:
-------
setTimeout(function() { }, interval);

// Use clearTimeout(ref.current) to cancel


1/08
=====

 1. Event Binding Types
Event Binding is the process of assigning an event (like a click, keypress, etc.) to a handler function. The common types of events are:

 Mouse Events
onClick

onMouseOver

onMouseOut

onMouseMove

 Keyboard Events
onKeyDown

onKeyUp

onKeyPress

 Button Events
onClick

onDoubleClick

onSubmit (if the button is in a form)

 Element State Events
onChange

onFocus

onBlur

 Timer Events
Used to delay or repeat tasks using JavaScript timers.

js
Copy
Edit
setTimeout(callback, delay);
clearTimeout(reference);

setInterval(callback, interval);
clearInterval(reference);
 2. Throttling in React (Using setInterval)
 What is Throttling?
Throttling is the process of invoking a function repeatedly at regular intervals to limit the execution rate.

Executes at fixed intervals using setInterval().

Can be stopped using clearInterval().

 Syntax:
js
Copy
Edit
let ref = setInterval(() => {
   // task
}, 1000);

clearInterval(ref);
Throttle Demo: throttle-demo.jsx
jsx
Copy
Edit
import { useEffect, useState } from "react"

export function ThrottleDemo() {
    const [clock, setClock] = useState();

    function GetTime() {
        var now = new Date();
        setClock(now.toLocaleTimeString());
    }

    useEffect(() => {
        setInterval(GetTime, 1000);
    }, [])

    return (
        <div>
            <h1 className="text-center">{clock}</h1>
        </div>
    );
}
 3. useRef() Hook
🔸 What is useRef()?
Used to create mutable values that persist across renders.

Commonly used to store timers, DOM references, or counters.

Do not use useRef() values for direct rendering in the UI.

🔸 Syntax:
js
Copy
Edit
const ref = useRef(null);
ref.current = value;
 4. Stopwatch Example using useRef()
stop-watch.jsx
jsx
Copy
Edit
import { useRef, useState } from "react"

export function StopWatch() {
    const [hrs, setHours] = useState(0);
    const [min, setMin] = useState(0);
    const [sec, setSec] = useState(0);
    const [milliSec, setMilliSec] = useState(0);

    let thread = useRef(null);

    var ms = 0, s = 0, m = 0, h = 0;

    function StartTimer() {
        ms++;
        setMilliSec(ms);
        if (ms === 999) {
            s++;
            setSec(s);
            ms = 0;
        }
    }

    function handleStartClick() {
        thread.current = setInterval(StartTimer, 1);
    }

    function handleClearClick() {
        clearInterval(thread.current);
        setMilliSec(0);
        setSec(0);
        setMin(0);
        setHours(0);
    }

    return (
        <div className="container-fluid p-4">
            <div className="d-flex justify-content-center">
                <div className="w-50 fs-4">
                    <div className="row">
                        <div className="col p-3 border border-1"><span>{hrs} h</span></div>
                        <div className="col p-3 border border-1"><span>{min} m</span></div>
                        <div className="col p-3 border border-1"><span>{sec} s</span></div>
                        <div className="col p-3 border border-1"><span>{milliSec} ms</span></div>
                    </div>
                    <div className="mt-3">
                        <button onClick={handleStartClick} className="btn btn-primary">Start</button>
                        <button onClick={handleClearClick} className="btn mx-2 btn-secondary">Clear</button>
                    </div>
                </div>
            </div>
        </div>
    );
}
 5. API Interaction with useRef(): Carousel Example
🔸 API Used:
https://fakestoreapi.com/products/1

carousel-demo.jsx
jsx
Copy
Edit
import axios from "axios"
import { useEffect, useRef, useState } from "react"

export function CarouselDemo() {
    const [product, setProduct] = useState({ id: 0, title: null, description: null, image: null, category: null, price: 0, rating: { rate: 0, count: 0 } });

    let productId = useRef(1);

    function LoadProductManually(id) {
        axios.get(`https://fakestoreapi.com/products/${id}`)
            .then(response => setProduct(response.data));
    }

    function handleNextClick() {
        productId.current += 1;
        LoadProductManually(productId.current);
    }

    function handPreviousClick() {
        productId.current -= 1;
        LoadProductManually(productId.current);
    }

    function handleSeekbarChange(e) {
        productId.current = e.target.value;
        LoadProductManually(productId.current);
    }

    useEffect(() => {
        LoadProductManually(1);
    }, []);

    return (
        <div className="container-fluid d-flex justify-content-center">
            <div className="card w-50 p-2 mt-4">
                <div className="card-header text-center">{product.title}</div>
                <div className="card-body">
                    <div className="row">
                        <div className="col-1 d-flex flex-column justify-content-center align-items-center">
                            <button onClick={handPreviousClick} className="btn btn-dark bi bi-chevron-left"></button>
                        </div>
                        <div className="col-10">
                            <img src={product.image} width="100%" height="400" />
                            <div className="mt-2">
                                <input type="range" onChange={handleSeekbarChange} min="1" max="20" value={productId.current} className="form-range" />
                            </div>
                        </div>
                        <div className="col-1 d-flex flex-column justify-content-center align-items-center">
                            <button onClick={handleNextClick} className="btn btn-dark bi bi-chevron-right"></button>
                        </div>
                    </div>
                </div>
                <div className="card-footer text-center">
                    <button className="btn btn-success bi bi-play"></button>
                    <button className="btn btn-danger mx-2 bi bi-pause"></button>
                </div>
            </div>
        </div>
    );
}
 Summary Flow (Learning Order):
Event Binding → Learn all types: Mouse, Keyboard, Button, State.

Timer Events → setTimeout, clearTimeout, setInterval, clearInterval.

Throttle Concept → Use setInterval to control frequency.

useRef() Hook → Learn how to use useRef for timers or process control.

Stopwatch App → Apply useRef() and setInterval() for a timer UI.

API with useRef → Control API calls (e.g., carousel) using useRef().

4/08
=====

Ex: Throttle 

carousel-demo.jsx



import axios from "axios"

import { useEffect, useRef, useState } from "react"





export function CarouselDemo(){



    const [product, setProduct] = useState({id:0, title:null, description:null, image:null, category:null, price:0, rating:{rate:0, count:0}});

    const [status, setStatus] = useState(null);



    let productId = useRef(1);

    let thread = useRef(null);



    function LoadProductManually(id){

        axios.get(`https://fakestoreapi.com/products/${id}`)

        .then(response=>{

            setProduct(response.data);

        })

        setStatus('Slide Show - Manual');

    }



    function LoadProductAuto(){

        productId.current = productId.current + 1;

        axios.get(`https://fakestoreapi.com/products/${productId.current}`)

        .then(response=>{

            setProduct(response.data);

        })

        setStatus('Slide Show - Auto');

    }



    function handleNextClick(){

        productId.current = productId.current + 1;

        LoadProductManually(productId.current);

    }

    function handPreviousClick(){

        productId.current = productId.current - 1;

        LoadProductManually(productId.current);

    }

    function handleSeekbarChange(e){

         productId.current = parseInt(e.target.value);

         LoadProductManually(productId.current);

    }



    function handlePlayClick(){

        thread.current = setInterval(LoadProductAuto, 3000);

        setStatus('Slide Show - Auto');

    }

    function handlePauseClick(){

        clearInterval(thread.current);

        setStatus('Slide Show - Paused');

    }



    useEffect(()=>{

        LoadProductManually(1);

    },[])



    return(

        <div className="container-fluid d-flex justify-content-center">

            <div className="card w-50 p-2 mt-4">

                <div className="card-header text-center">

                    <div>{product.title}</div>

                    <div className="fw-bold">{status}</div>

                </div>

                <div className="card-body">

                    <div className="row">

                        <div className="col-1 d-flex flex-column justify-content-center align-items-center">

                            <button onClick={handPreviousClick} className="btn btn-dark bi bi-chevron-left"></button>

                        </div>

                        <div className="col-10">

                            <img src={product.image} width="100%" height="400" />

                            <div className="mt-2">

                                <input type="range" onChange={handleSeekbarChange} min="1" max="20" value={productId.current} className="form-range" />

                            </div>

                        </div>

                        <div className="col-1 d-flex flex-column justify-content-center align-items-center">

                            <button onClick={handleNextClick} className="btn btn-dark bi bi-chevron-right"></button>

                        </div>

                    </div>

                </div>

                <div className="card-footer text-center">

                    <button onClick={handlePlayClick} className="btn btn-success bi bi-play"></button>

                    <button onClick={handlePauseClick} className="btn btn-danger mx-2 bi bi-pause"></button>

                </div>

            </div>

        </div>

    )

}



Summary

1. Mouse Events

2. Keyboard Events

3. Button Events

4. Element State Events

5. Timer Events

6. Clipboard Events

       onCut

       onCopy

       onPaste



                                                   React Form Events

 - React requires various event binding techniques to handle forms.

 - React recommends to use 3rd party form libraries to design and validate forms.

 - The popular 3rd party form libraries are

           a) Formik

           b) React Hook Form

           c) Telerik Kendo Form  etc.



Ex: Handling Form without any 3rd party library



form-demo.jsx



import { useState } from "react";



export function FormDemo(){



    const [userDetails, setUserDetails] = useState({UserName:null, Mobile:null, City:null});



    function handleSubmit(e){

        e.preventDefault();

        alert('Form Submitted');

        console.log(userDetails);

    }



    function handleNameChange(e){

        setUserDetails(

            {

                UserName: e.target.value,

                Mobile: userDetails.Mobile,

                City: userDetails.City

            }

        )

    }



    function handleMobileChange(e){

        setUserDetails(

            {

                UserName: userDetails.UserName,

                Mobile: e.target.value,

                City: userDetails.City

            }

        )

    }



    function handleCityChange(e){

        setUserDetails(

            {

                UserName: userDetails.UserName,

                Mobile: userDetails.Mobile,

                City: e.target.value

            }

        )

    }



    return(

        <div className="container-fluid">

            <h2>Register User</h2>

            <form onSubmit={handleSubmit}>

                <dl>

                    <dt>User Name</dt>

                    <dd><input type="text" onChange={handleNameChange} name="UserName" /></dd>

                    <dt>Mobile</dt>

                    <dd><input type="text" onChange={handleMobileChange} name="Mobile" /></dd>

                    <dt>City</dt>

                    <dd>

                        <select name="City" onChange={handleCityChange}>

                            <option>Select City</option>

                            <option>Delhi</option>

                            <option>Hyd</option>

                        </select>

                    </dd>

                </dl>

                <button type="submit">Register</button>

            </form>

        </div>

    )

}

 



Formik for React Forms: 

 - Formik is a 3rd party form library for React.

 - It provides pre-defined services using hooks and components.

 - It simplifies the form interactions and enables security. 



1. Install Formik 



       > npm install formik —save



2. Import “useFormik()” hook into component. 



   import  { useFormik }  from “formik”;



3. Configure the form using useFormik hook



    const formik = useFormik({ 

   

               initialValues: { },                  // refers to the form values that formik handles 

               onSubmit: ()=>{ },              // It defines actions to perform on submit

               validate: ()=>{ },                  // It uses a function to validate the form values.

               validationSchema:()=>{}, // It uses a function that returns validation schema. 

               enableReinitialize: true/fasle   // Allows reinitialization [two way binding]  

     })



4. Bind formik events with form elements



       <form  onSubmit={ formik.handleSubmit } > 



       <input type=“text”  onChange={ formik.handleChange } />

       <select onChange= { formik.handleChange } />



Note: Every form element requires a “name” attribute and it must map with formik initialValues. 



5. Formik provides built in event handlers like



           formik.handleChange

           formik.handleBlur

           formik.handleSubmit 

           etc.



   Event handler requires events like

   

           onSubmit

           onChange

           onBlur 

           etc.



Ex:

 form-demo.jsx



import { useState } from "react";

import { useFormik } from "formik";



export function FormDemo(){



    

    const formik = useFormik({

         initialValues: {

            UserName: null, 

            Mobile: null,

            City: null

         },

         onSubmit: (user)=>{

             console.log(user);

         }

    })



    return(

        <div className="container-fluid">

            <h2>Register User</h2>

            <form onSubmit={formik.handleSubmit} >

                <dl>

                    <dt>User Name</dt>

                    <dd><input type="text" onChange={formik.handleChange}  name="UserName" /></dd>

                    <dt>Mobile</dt>

                    <dd><input type="text" onChange={formik.handleChange} name="Mobile" /></dd>

                    <dt>City</dt>

                    <dd>

                        <select name="City" onChange={formik.handleChange} >

                            <option>Select City</option>

                            <option>Delhi</option>

                            <option>Hyd</option>

                        </select>

                    </dd>

                </dl>

                <button type="submit">Register</button>

            </form>

        </div>

    )

}



Formik Validation: 

 - Validation is the process of verifying user input. 

 - Validation is required to ensure that contradictory and unauthorised data is not get stored into database. 

 - Formik allows to configure custom validation function, where developer have to define

   Validations manually. 

 - Formik supports validation schema, which provides built-in validation services.



Ex: Custom Validation Function



import { useState } from "react";

import { useFormik } from "formik";



export function FormDemo(){



    function ValidateUser(user){

        var errors = {UserName:'', Mobile:'', City:''};



        if(user.UserName.length===0) {

            errors.UserName = 'User Name Required';

        } else {

            if(user.UserName.length<4){

                errors.UserName = 'Name too short';

            }

        }



        if(user.Mobile.length===0){

            errors.Mobile = 'Mobile Required';

        } else {

            if(user.Mobile.match(/\+91\d{10}/)) {

                errors.Mobile = '';

            } else {

                errors.Mobile = 'Invalid Mobile';

            }

        }



        if(user.City === '-1') {

            errors.City = 'Please select your city';

        }



        return errors;

    }

    

    const formik = useFormik({

         initialValues: {

            UserName: '', 

            Mobile: '',

            City: ''

         },

         validate: ValidateUser,

         onSubmit: (user)=>{

             console.log(user);

         }

    })



    return(

        <div className="container-fluid">

            <h2>Register User</h2>

            <form onSubmit={formik.handleSubmit} >

                <dl>

                    <dt>User Name</dt>

                    <dd><input type="text" onChange={formik.handleChange}  name="UserName" /></dd>

                    <dd className="text-danger">{formik.errors.UserName}</dd>

                    <dt>Mobile</dt>

                    <dd><input type="text" onChange={formik.handleChange} name="Mobile" /></dd>

                    <dd className="text-danger">{formik.errors.Mobile}</dd>

                    <dt>City</dt>

                    <dd>

                        <select name="City" onChange={formik.handleChange} >

                            <option value="-1">Select City</option>

                            <option>Delhi</option>

                            <option>Hyd</option>

                        </select>

                    </dd>

                    <dd className="text-danger">{formik.errors.City}</dd>

                </dl>

                <button type="submit">Register</button>

            </form>

        </div>

    )

}

5/08
=====

- Formik Library
- useFormik()
- Collect data from form and submit to server
       handleChange
       handleSubmit
- Validation

Note: It is recommended to disable the default validations of HTML.
         By using form “novalidate” attribute.

         <form  method=“”  action=“”  novalidate> </form>
                                                           Yup Library
- It is a validation services library.
- It provides pre-defined business logic to verify and validate the input values.
- You can customize and implement according to requirements. 

1. Install yup library for project. 

       > npm install yup  -- save 

2. Import any specific validation service or you can import all services from “yup”. 

       import   { required, minlength }  from “yup”;
                                  (or)
       import  *  as  yup  from “yup”;

3. Configure the validation schema for formik 

       useFormik( {
               initialValues : { },
               validationSchema: yup.object({ 

                       fieldname: yup.dataType().required(“message”).minLength(number, “msg”)..,
                       fieldname: yup.dataType().required()..

               }),
               onSubmit : (values) => { }
          })

4. Binding & Displaying errors is same as you defined for formik.

       <input  type=“text”  onChange={formik.handleChange}>
       <div> { formik.errors.fieldname } </div>

Ex:
 form-demo.jsx

import { useState } from "react";
import { useFormik } from "formik";
import * as yup from "yup";

export function FormDemo(){  
    const formik = useFormik({
         initialValues: {
            UserName: '', 
            Mobile: '',
            City: ''
         },
         validationSchema: yup.object({
             UserName: yup.string().required('User Name Required').min(4,'Name too short'),
             Mobile: yup.string().required('Mobile Required').matches(/\+91\d{10}/, 'Invalid Mobile')
         }) ,
         onSubmit: (user)=>{
             console.log(user);
         }
    })
    return(
        <div className="container-fluid">
            <h2>Register User</h2>
            <form onSubmit={formik.handleSubmit} >
                <dl>
                    <dt>User Name</dt>
                    <dd><input type="text" onChange={formik.handleChange}  name="UserName" /></dd>
                    <dd className="text-danger">{formik.errors.UserName}</dd>
                    <dt>Mobile</dt>
                    <dd><input type="text" onChange={formik.handleChange} name="Mobile" /></dd>
                    <dd className="text-danger">{formik.errors.Mobile}</dd>
                    <dt>City</dt>
                    <dd>
                        <select name="City" onChange={formik.handleChange} >
                            <option value="-1">Select City</option>
                            <option>Delhi</option>
                            <option>Hyd</option>
                        </select>
                    </dd>
                    <dd className="text-danger">{formik.errors.City}</dd>
                </dl>
                <button type="submit">Register</button>
            </form>
        </div>
    )
}

Note: The default validations fireup when user submits a form. You can bind blur event to
          validate on blur. 

           <input  onChange={ formik.handleChange}  onBlur={ formik.handleBlur } />

           
- Formik provides a “rest” argument that allows to bind all events to any element. 
- It uses a formik method “getFieldProps()” to access all properties and bind with element.

           <input  type=“text” name=“UserName”  { …formik.getFieldProps(“UserName”) } />

Ex:
import { useState } from "react";
import { useFormik } from "formik";
import * as yup from "yup";

export function FormDemo(){    
    const formik = useFormik({
         initialValues: {
            UserName: '', 
            Mobile: '',
            City: ''
         },
         validationSchema: yup.object({
             UserName: yup.string().required('User Name Required').min(4,'Name too short'),
             Mobile: yup.string().required('Mobile Required').matches(/\+91\d{10}/, 'Invalid Mobile')
         }) ,
         onSubmit: (user)=>{
             console.log(user);
         }
    })

    return(
        <div className="container-fluid">
            <h2>Register User</h2>
            <form onSubmit={formik.handleSubmit} >
                <dl>
                    <dt>User Name</dt>
                    <dd><input type="text" {...formik.getFieldProps("UserName")}  name="UserName" /></dd>
                    <dd className="text-danger">{formik.errors.UserName}</dd>
                    <dt>Mobile</dt>
                    <dd><input type="text" {...formik.getFieldProps("Mobile")} name="Mobile" /></dd>
                    <dd className="text-danger">{formik.errors.Mobile}</dd>
                    <dt>City</dt>
                    <dd>
                        <select name="City" {...formik.getFieldProps("City")} >
                            <option value="-1">Select City</option>
                            <option>Delhi</option>
                            <option>Hyd</option>
                        </select>
                    </dd>
                    <dd className="text-danger">{formik.errors.City}</dd>
                </dl>
                <button type="submit">Register</button>
            </form>
        </div>
    )
}

- Formik provides validation at 2 levels

       a) Input State Validation
       b) Form State Validation

- Input state is used to verify every field individually. It uses “formik.errors” to access errors for any specific field. 

               { formik.errors.fieldName } 

- Form state is used to verify all fields in a form simultaneously at the same time. 
 Form state services are 
              a) touched                : got focus and blur
              b) dirty                    : modified [ any one field modified ]
              c) isValid                : all field are valid
              d) errors                    : returns all field errors. 
              e) values                    : returns all fields values. 

Syntax:
           <button disabled={ (formik.dirty) ? false : true }> 
Ex:
Form-demo.jsx

import { useState } from "react";
import { useFormik } from "formik";
import * as yup from "yup";

export function FormDemo(){
   const formik = useFormik({
        initialValues: {
           UserName: '', 
           Mobile: '',
           City: ''
        },
        validationSchema: yup.object({
            UserName: yup.string().required('User Name Required').min(4,'Name too short'),
            Mobile: yup.string().required('Mobile Required').matches(/\+91\d{10}/, 'Invalid Mobile')
        }) ,
        onSubmit: (user)=>{
            console.log(user);
        }
   })
   return(
       <div className="container-fluid">
           <h2>Register User</h2>
           <form onSubmit={formik.handleSubmit} >
               <dl>
                  <dt>User Name</dt>
                   <dd><input type="text" {...formik.getFieldProps("UserName")}  name="UserName" /></dd>
                   <dd className="text-danger">{formik.errors.UserName}</dd>
                   <dt>Mobile</dt>
                   <dd><input type="text" {...formik.getFieldProps("Mobile")} name="Mobile" /></dd>
                   <dd className="text-danger">{formik.errors.Mobile}</dd>
                   <dt>City</dt>
                   <dd>
                       <select name="City" {...formik.getFieldProps("City")} >
                           <option value="-1">Select City</option>
                           <option>Delhi</option>
                           <option>Hyd</option>
                       </select>
                   </dd>
                   <dd className="text-danger">{formik.errors.City}</dd>
               </dl>
               <button disabled={(formik.isValid)?false:true} className="mx-2" type="submit">Register</button>
               <button  className={(formik.dirty)?'d-inline':'d-none'}  disabled={(formik.dirty)?false:true} type="submit">Save</button>
           </form>
       </div>
   )
}


                                                    Formik Components



6/08
======

Formik 

- useFormik()
- handleChange
- handleBlur
- handleSubmit
- dirty
- isValid
- touched
- errors
- values 
- yup [ for validation ]
- getFieldProps()

                                Formik Components
- Component have pre-defined design, styles and logic.
- You can customize and implement according to the requirements.
- Class components in React can’t use hooks, it requires components to configure a form. 
- Formik components include:
           <Formik>                    It configures a container for form
           <Form>                        It configures a container for elements
           <Field>                        It configures individual element
           <ErrorMessage>        It configures an error log for field.

Syntax:
          <Formik  initialValues={ }  onSubmit={ }  validate={ }  validationSchema={ }>
                <Form>
                      <Field type=“text | password | radio..”> </Field>
                      <ErrorMessage> </ErrorMessage>
               </Form>
           </Formik>

Ex: formik-demo.jsx

import { Formik, Form, Field, ErrorMessage } from "formik";
import * as yup from "yup";

export function FormikDemo(){
   return(
       <div className="container-fluid">
           <h2>Register User</h2>
           <Formik initialValues={{UserName:'', Mobile:''}} validationSchema={yup.object({UserName: yup.string().required('User Name Required').min(4, 'Name too short'), Mobile: yup.string().required('Mobile Required').matches(/\+91\d{10}/,'Invalid Mobile')})} onSubmit={(values)=>{console.log(values)}} >
               <Form>
                   <dl>
                       <dt>User Name</dt>
                       <dd><Field type="text" name="UserName" /></dd>
                       <dd className="text-danger"> <ErrorMessage name="UserName" /> </dd>
                       <dt>Mobile</dt>
                       <dd><Field type="text" name="Mobile" /></dd>
                       <dd className="text-danger"> <ErrorMessage name="Mobile" /> </dd>
                   </dl>
                   <button type="submit">Submit</button>
               </Form>
           </Formik>
       </div>
   )
}
- You can configure the form state by accessing the form properties, It requires a reference for <Form> component. 

Syntax:
                  <Formik>
                      {
                         form => <Form> </Form>
                      }
                      { form.dirty,  form.isValid,  form.values, form.errors .. }
                  </Formik>

Ex: formik-demo.jsx
import { Formik, Form, Field, ErrorMessage } from "formik";
import * as yup from "yup";

export function FormikDemo(){
   return(
       <div className="container-fluid">
           <h2>Register User</h2>
           <Formik initialValues={{UserName:'', Mobile:''}} validationSchema={yup.object({UserName: yup.string().required('User Name Required').min(4, 'Name too short'), Mobile: yup.string().required('Mobile Required').matches(/\+91\d{10}/,'Invalid Mobile')})} onSubmit={(values)=>{console.log(values)}} >
               {
                   form => 
                   <Form>
                   <dl>
                       <dt>User Name</dt>
                       <dd><Field type="text" name="UserName" /></dd>
                       <dd className="text-danger"> <ErrorMessage name="UserName" /> </dd>
                       <dt>Mobile</dt>
                       <dd><Field type="text" name="Mobile" /></dd>
                       <dd className="text-danger"> <ErrorMessage name="Mobile" /> </dd>
                   </dl>
                   <button disabled={(form.isValid)?false:true} type="submit">Submit</button>
                   <div className="mt-4 text-danger" style={{display:(form.isValid)?'none':'block'}} >
                       <h4>Please check the following errors</h4>
                       <ul>
                          {
                              Object.keys(form.errors).map(key =>
                                <li key={key}> {form.errors[key]} </li>
                              )
                          }
                        </ul>
                    </div>
                   </Form>
                }
            </Formik>
        </div>
    )
}
                    React Hook Form
  - https://react-hook-form.com/
       1. What are the features of Hook Form?
       2. What are the issues with Hook Form? 
       3. How to configure a form?
       4. How to validate a form?
Summary
- Design Component
- Style Binding
- Class Binding
- Data Binding
- Event Binding
- Forms 

FAQ: What’s new in React 19 Forms?
Ans:
       a) form action    : It configures a server side function to execute on form submit. 
          Syntax:
                      <form  action={serverFunction} >
       b) FormData        : It is a new API to collect the form data without manually creating 
                                    reference for accessing data.
Ex: form-new.jsx

export function FormNew(){

   function handleSubmit(e){
       e.preventDefault();
       const data = new FormData(e.target);
       for(var item of data){
           console.log(item[1]);
       }
   }
   return(
       <div className="container-fluid">
           <h2>Register</h2>
           <form onSubmit={handleSubmit}>
                <dl>
                    <dt>User Name</dt>
                    <dd><input type="text" name="UserName" /></dd>
                      <dt>Mobile</dt>
                    <dd><input type="text" name="Mobile" /></dd>
                </dl>
                <button type="submit">Submit</button>
            </form>
        </div>
    )
}

7/08
=====

React Hook Form

Features:

1. Performant 
   - Faster Mounting
   - Avoids re-render
   - Light weight 
   - Uses Native HTML

2. Flexible and Extensible 
   - Dynamically can render elements.
   - Add new features into form without modifying the form.

3. Easy to Validate
   - It uses HTML validations.
   - It doesn’t require any validation library.
  
Issues: 
   - It completely configured with hooks.
   - It is not suitable for application that uses class components.
   - HTML validations require customization.

How to explore a library?
- Library related all features are defined in “API”.
- Developer must first explore the API of a library.
- API gives a complete overview of library along with versions.
- After overview to start using all features you have to go to “Get Started”.

Setup and use Hook form:
1. Install Hook Form for project
        > npm  install   react-hook-form --save
2. Import  “useForm()” hook into component
      import   { useForm }  from  “react-hook-form”;
3. Configure form 
       const { register, handleSubmit,  formState: {errors} } = useForm(); 
       register        : It refers to form and its elements.
                         It can access all element properties and events.
                               - value
                               - name
                               - onChange
                               - onBlur etc.
       handleSubmit: It defines actions to perform on submit.
       formState        : It returns errors object that comprises of field errors.
3. Configure submit action
           const  submit  = (values) => {
                   console.log(values);
            }    
4. Configure form and elements
           <form  onSubmit= { handleSubmit(submit) } >
           </form>
           <input type=“text”  name=“UserName”  { …register(“UserName”, { required:true, minLength:4, pattern=/[A-Z]{4,10}/ }) } />
           <input type=“text” name=“Mobile” { …register(“Mobile”, { required:true, pattern=/\+91\d{10}/ }) } />

5. Handling Error message 
           {  (errors.fieldName?.type===“required” ) ? <span> true </span> : <span> false </span> }
           { (exp1 ) && (exp2) && (exp3) }

Ex:
       UserName : string        required, 4 to 15 chars
       Mobile : string            required , +91 and 10 digits
       Age : number            required , 15 to 30 only
       City : string                required 
                                                   Conditional Rendering
                                                   Controlled Components


8/08
=====

Controlled Components

- Components are uncontrolled, which refer to absolute. 
- You can reuse a component in the same way at every occurrence. 
- You can’t customize according to requirements. 
- React allows to create controlled components, which allow customization. 
- A controlled component is usually controlled by the data from its parent. 
- Technically controlled component is a function that takes “properties” as arguments and modify the functionality. 

Syntax:

                   function Component(props)
                   {
                        return( 
                                   <>
                                   </>
                                   )    
                   }

-  “Props” is a formal parameter of “Object” type. 
-  It is a key and value collection. 
Syntax:
               function  Component(props)
               {
                   return ( <h2> { props.title } </h2> )
               }

               <Component  title=“value” />

Ex:

1. Add a new folder into “src” by name “controlled-components”

2. Add a new file by name  

“navbar.jsx”

export function Navbar(props){
    return(
        <nav className={`d-flex ${props.theme} my-2 align-items-center justify-content-between p-2 border border-1 border-secondary`}>
            <div><span className="fs-4 fw-bold">{props.brandTitle}</span></div>
            <div>
                {
                    props.navItems.map(item => <span key={item} className="mx-3"> {item} </span>)
                }
            </div>
            <div>
                <button className="btn btn-danger">Signin</button>
            </div>
        </nav>
    )
}

3. Import Navbar into your components

form-new.jsx

import { useState } from "react";
import { Navbar } from "../../controlled-components/navbar";
export function FormNew(){
    const [amazonItems] = useState(['Home', 'About', 'Mobiles', 'Fashion', 'Contact']);

    function handleSubmit(e){
        e.preventDefault();
        const data = new FormData(e.target);
        for(var item of data){
            console.log(item[1]);
        }
    }
  
    return(
        <div className="container-fluid">
            <header className="mt-3">
                <Navbar theme='bg-warning' brandTitle="Shopper." navItems={['Home', 'Shop', 'Pages', 'Blog', 'Docs']} />
            </header>
            <section>
                <Navbar theme='bg-dark text-white' brandTitle="Amazon" navItems={amazonItems} />
            </section>
            <h2>Register</h2>
            <form onSubmit={handleSubmit}>
                <dl>
                    <dt>User Name</dt>
                    <dd><input type="text" name="UserName" /></dd>
                      <dt>Mobile</dt>
                    <dd><input type="text" name="Mobile" /></dd>
                </dl>
                <button type="submit">Submit</button>
            </form>
        </div>
    )
}

Ex:

1. Enable bootstrap jQuery functionality “main.jsx”

import '../node_modules/bootstrap/dist/js/bootstrap.bundle.js';

2. Controlled-components/ data-grid.jsx

export function DataGrid(props){
    return(
        <table className="table table-hover caption-top">
            <caption>{props.caption}</caption>
            <thead>
                <tr>
                    {
                        props.fields.map(field=>
                        <th key={field}>{field} 
                          <div className="dropdown d-inline">
                             <button data-bs-toggle="dropdown" className="bi bi-three-dots-vertical btn"></button> 
                             <ul className="dropdown-menu">
                                <li className="dropdown-item"> <span className="dropdown-item-text"> <span className="bi bi-sort-alpha-down"></span> Sort Ascending </span> </li>
                                <li className="dropdown-item"> <span className="dropdown-item-text"> <span className="bi bi-sort-alpha-up"></span> Sort Descending </span> </li>
                                <li className="dropdown-item"> <span className="dropdown-item-text"> <span className="bi bi-flask"></span> Filter </span> </li>
                             </ul>
                          </div>
                        </th>)
                    }
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody>
                {
                    props.data.map((item,index)=>
                     <tr key={index}>
                        {
                            Object.keys(item).map(key => <td key={key}> {item[key]} </td>)
                        }
                        <td>
                            <button className="btn btn-warning bi bi-pen-fill"></button>
                            <button className="btn btn-danger bi bi-trash mx-2"></button>
                        </td>
                     </tr>
                    )
                }
            </tbody>
        </table>
    )
}

3.  controlled-demo.jsx

import { DataGrid } from "../../controlled-components/data-grid";

export function ControlledDemo(){
    return(
        <div className="container-fluid">
            <h2>Employee Details</h2>
            <DataGrid  caption='Employee Data - Update Aug 2025' fields={['First Name', 'Last Name', 'Designation', 'Salary']} data={[{FirstName:'Raj', LastName:'Kumar', Designation:'Clerk', Salary:45000},{FirstName:'Kiran', LastName:'Kumar', Designation:'Manager', Salary:75000}]} />
            <h2>Product Details</h2>
            <DataGrid caption='Products in Offer' fields={['Name', 'Price', 'Rating']} data={[{Name:'TV', Price:24000, Rating:4.2}, {Name:'Mobile', Price:12000, Rating:3.2}, {Name:'Watch', Price:3000, Rating:4.9}]} />
        </div>
    )
}

11/08
======
Conditional Rendering

- It is the process of rendering content according to the state and situation. 
- A component can change its format and behaviour accordingly.

1. Conditionally Rendering Component
   - You can access any another component and render into current context.
   - It requires a reference for handling component. 
   Syntax:
           const [view, setView] = useState(null);

           if(condition)
           {
               setView( <Component-1/>);
           }
           else 
           {
               setView( <Component-2 />);
           }

Ex: conditional-demo.jsx

import { useState } from "react"
import { EMICalculator } from "../emi-calculator/emi-calculator";
import { CarouselDemo } from "../carousel-demo/carousel-demo";

export function ConditionDemo(){

    const [view, setView] = useState(null);

    function handleEmi(){
        setView(<EMICalculator />);
    }
    function handleCarousel(){
        setView(<CarouselDemo />)
    }

    return(
        <div className="container-fluid">
            <h2>Home</h2>
            <button onClick={handleEmi} className="btn btn-primary">EMI Calculator</button>
            <button onClick={handleCarousel} className="btn btn-warning mx-2">Carousel</button>
            <hr />
            <div>
                {view}
            </div>
        </div>
    )
}

2. A component can render different content according to specified condition.
    It requires a component to configure with multiple return statements. 

Syntax:
       function Component(props)
       {
           if(props===‘’) {
               return ( <div> JSX1 </div> );
           }
           else {
               return ( <div> JSX 2 </div> );
           }
       }

Ex:
1. Go to  controlled-component/ data-grid.jsx

export function DataGrid(props){

    if(props.layout==='grid'){
        return(
        <table className="table table-hover caption-top">
            <caption>{props.caption}</caption>
            <thead>
                <tr>
                    {
                        props.fields.map(field=>
                        <th key={field}>{field} 
                          <div className="dropdown d-inline">
                             <button data-bs-toggle="dropdown" className="bi bi-three-dots-vertical btn"></button> 
                             <ul className="dropdown-menu">
                                <li className="dropdown-item"> <span className="dropdown-item-text"> <span className="bi bi-sort-alpha-down"></span> Sort Ascending </span> </li>
                                <li className="dropdown-item"> <span className="dropdown-item-text"> <span className="bi bi-sort-alpha-up"></span> Sort Descending </span> </li>
                                <li className="dropdown-item"> <span className="dropdown-item-text"> <span className="bi bi-flask"></span> Filter </span> </li>
                             </ul>
                          </div>
                        </th>)
                    }
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody>
                {
                    props.data.map((item,index)=>
                     <tr key={index}>
                        {
                            Object.keys(item).map(key => <td key={key}> {item[key]} </td>)
                        }
                        <td>
                            <button className="btn btn-warning bi bi-pen-fill"></button>
                            <button className="btn btn-danger bi bi-trash mx-2"></button>
                        </td>
                     </tr>
                    )
                }
            </tbody>
        </table>
    )
    } else {
        return(
            <div className="d-flex flex-wrap">
                
                    {
                        props.data.map((item,i)=> 
                            <div key={i} className="card m-2 p-2" style={{width:'200px'}}>
                                <div className="card-header">
                                    {
                                        Object.keys(item)[0]
                                    }
                                </div>
                                <div className="card-body">
                                    {
                                        item[Object.keys(item)[0]]
                                    }
                                </div>
                                <div className="card-footer"> 
                                    <button className="btn btn-warning bi bi-pen-fill"></button>
                                    <button className="btn mx-2 btn-danger bi bi-trash-fill"></button>
                                </div>
                            </div>
                        )
                    }                
            </div>
        )
    }
}

2. Controlled-demo.jsx
import { useState } from "react";

import { DataGrid } from "../../controlled-components/data-grid";
export function ControlledDemo(){

    const [layoutName, setLayoutName] = useState('grid');

    function handleLayoutChange(e){
        setLayoutName(e.target.value);
    }

    return(
        <div className="container-fluid">
           
            <h2>Employee Details 
                <select className="mx-2" onChange={handleLayoutChange}>
                  <option>Select View</option> 
                  <option value='grid'>Grid</option>   
                  <option value='card'>Card</option>
                </select> 
            
            </h2>
            <DataGrid layout={layoutName} caption='Employee Data - Update Aug 2025' fields={['First Name', 'Last Name', 'Designation', 'Salary']} data={[{FirstName:'Raj', LastName:'Kumar', Designation:'Clerk', Salary:45000},{FirstName:'Kiran', LastName:'Kumar', Designation:'Manager', Salary:75000}]} />
            <h2>Product Details</h2>
            <DataGrid layout='card' caption='Products in Offer' fields={['Name', 'Price', 'Rating']} data={[{Name:'TV', Price:24000, Rating:4.2}, {Name:'Mobile', Price:12000, Rating:3.2}, {Name:'Watch', Price:3000, Rating:4.9}]} />
        </div>
    )
}

3. A component can render different content within specific context area. 
   You can change the content inside component using conditional rendering.

Syntax:
       {
         (condition) ? <span> A </span> : <span> B </span> 
       }

Ex: condition-demo.jsx

import { useEffect, useState } from "react"
export function ConditionDemo(){

    const [username, setUserName] = useState(null);    

    function handleNameChange(e){
        setUserName(e.target.value);
    }

    function handleSigninClick(){
        window.sessionStorage.setItem('uname', username);
        location.reload();
        
    }
    function handleSignoutClick(){
        window.sessionStorage.removeItem('uname');
        location.reload();
    }
   
    useEffect(()=>{
       
    },[])

    return(
        <div className="container-fluid">
            <header className="m-2 d-flex align-items-center justify-content-between p-2 border border-1">
                <div className="fs-5 fw-bold">Amazon</div>
                <nav>
                    <span>Home</span>
                    <span className="mx-4">Shop</span>
                    <span>Contact</span>
                </nav>
                <div>
                   {
                     (window.sessionStorage.getItem('uname')===null) 
                     ?
                     <div className="input-group">
                        <input type="text" className="form-control" onChange={handleNameChange} placeholder="User Name" />  <button onClick={handleSigninClick} className="btn btn-danger">Signin</button>
                     </div> 
                     :
                     <div className="fw-bold">
                        {
                            window.sessionStorage.getItem('uname')
                        }
                        <button onClick={handleSignoutClick} className="btn mx-2 btn-danger">Signout</button>
                     </div>
                   }
                </div>
            </header>
        </div>
    )
}

12/08
======
React Hooks

- Hook is a service.
- Service is a pre-defined business logic, which you can customize and implement according to the requirements.
- Service is a set of factories.
- Factory is a set of relative values and functions. 
- Service uses a singleton pattern, where an object is created for first request and the same is used across multiple requests. 
- Service comprises of various components
   a) Provider
   b) Injector
   c) Consumer 

- Consumer uses the service.
- Provider locates the service in memory. 
- Injector identifies the dependencies required for service and injects into component. 
- The process of identifying dependencies and injecting into application is known as “Dependency Injection” [DI].

Configuring Hook:
- Technically hook is a JavaScript function.
- Hook function name must be in camel case.   [ camelCase ]
- It must return a value or function. 
- It can’t be void type. 
- It can be parameterless or parameterized. 
- It can be accessed and used only at higher level of a component. 

               function useHook()
               {
                    return ( );
               }


               function Component()
               {
                         const ref = useHook();    // valid
                         function handleClick()
                         {
                            const [ref] = useState();  // invalid
                         }
               }

- Hook can’t be used in a class component. 
- JavaScript class member can be a 
       a) Constructor
       b) Property
       c) Method
       d) Accessor 
- Function can’t be a class member.
- Hook name must start with “use” from react 19x versions. 
 
React Hook Library:
- React allows to create custom hooks.
- React also provides pre-defined hooks. 

Custom Hook:
1. Create a new folder by name “hooks” and add into “src” 

2. Add a new “.jsx” file for hook

           use-captcha.jsx


export function useCaptcha()
{
    const code = `${Math.round(Math.random()*10)} ${Math.round(Math.random()*10)} ${Math.round(Math.random()*10)} ${Math.round(Math.random()*10)} ${Math.round(Math.random()*10)} ${Math.round(Math.random()*10)}`;
    return code;
}


3. Import and inject into component  “login.jsx”

import './login.css';
import { useCaptcha } from '../../hooks/use-captcha';

export function Login(){


    const code = useCaptcha();

    return(
        <>
           <div className='d-flex justify-content-center'>
              <form className="login-form mt-4 rounded rounded-2">
                <h2 className='bi bi-person-circle'> User login</h2>
                <dl>
                  <dt>User Name</dt>
                  <dd><input type="text" className='form-control' /></dd>
                  <dt>Password</dt>
                  <dd><input type="password" className='form-control' /></dd>
                  <dt>Verify Code <button className='btn bi bi-arrow-clockwise'></button> </dt>
                  <dd>{code}</dd>
                </dl>
                <button className='btn btn-warning w-100'>Login</button>
            </form>
           </div>
        </>
    )
}

Note: Hooks is a JSX file, hence it allows all React libraries.
         You can use existing React libraries in a hook function. 

Ex:
1. Hooks / use-fetch.jsx

import axios from "axios";
import { useEffect, useState } from "react";

export function useFetch(url){
    const [data, setData] = useState([]);


    useEffect(()=>{

        axios.get(url).then(response=>{
        setData(response.data);
       })

    },[url])

    return data;
}

2. Implement in any component  login.jsx

import './login.css';
import { useCaptcha } from '../../hooks/use-captcha';
import { useFetch } from '../../hooks/use-fetch';

export function Login(){

    const code = useCaptcha();

    const categories = useFetch('https://fakestoreapi.com/products/categories&#39;);

    return(
        <>
           <div className='d-flex justify-content-center'>
              <form className="login-form mt-4 rounded rounded-2">
                <h2 className='bi bi-person-circle'> User login</h2>
                <dl>
                  <dt>User Name</dt>
                  <dd><input type="text" className='form-control' /></dd>
                  <dt>Password</dt>
                  <dd><input type="password" className='form-control' /></dd>
                  <dt>Verify Code <button className='btn bi bi-arrow-clockwise'></button> </dt>
                  <dd>{code}</dd>
                </dl>
                <button className='btn btn-warning w-100'>Login</button>
                <ul>
                  {
                    categories.map(category=> <li key={category}>{category}</li>)
                  }
                </ul>
            </form>
           </div>
        </>
    )
}

13/08
======

React Hooks
- Custom Hooks

Task:

1. Create a hook for sorting the data

          useSort(data, reverse:true/false)
           data = [ string ]

2. Create a hook for filtering data

           useDataFilter(data, searchString);
           data = [ { }, { } ]

3. Create a hook for converting a string into title case. [every word first letter caps]

           useTitleCase(msg);    
           useTitleCase(“weLCOme to rEaCt”);   // Welcome To React

React Built-In Hooks:

1. useEffect()

   - It defines actions to perform on component mount and unmount. 
   - Every component have 3 phases
           a) Mount
           b) Update
           c) Unmount 

 Component Life Cycle:

       componentWillMount()
       componentDidMount()
       componentDidUpdate()
       componentWillUnmount()


14/08
======

1. useEffect()
   
FAQ: When a component unmounts?
Ans:  Current component unmounts when user navigates to next component or closes the
         application. 

Syntax:
           useEffect(()=> {
                  // mount actions

                  return ()=> { 
                       // unmount actions
                   }

           },[ dependencies ])

Ex:

import { useEffect, useState } from "react"

export function UserLogin(){

    useEffect(()=>{
        console.log('Login Component Mounted');
        return()=>{
            console.log('Login Component Unmounted');
        }
    },[])

    return(
        <div>
            <h3>User Login</h3>
        </div>
    )
}

export function UserRegister(){
    useEffect(()=>{
        console.log('Register Component Mounted');
        return()=>{
            console.log('Register Component Unmounted');
        }
    },[])
    return(
        <div>
            <h3>User Register</h3>
        </div>
    )
}


export function LifeCycleDemo(){

    const [component, setComponent] = useState(null);

    function handleLoginClick(){
        setComponent(<UserLogin />);
    }
    function handleRegisterClick(){
        setComponent(<UserRegister/>);
    }

   return(
    <div className="container-fluid">
        <h2>Life Cycle Home</h2>
        <button onClick={handleLoginClick}>Login</button>
        <button onClick={handleRegisterClick}>Register</button>
        <hr />
        <div>
            {
                component
            }
        </div>
    </div>
   )
}


2. useState() 
   - It uses the local state configured for component.
   - State of current component is not accessible to its child or other components. 
   - It returns a getter and setter.

Syntax:
       const [getter, setter] = useState(‘initializer’);

   FAQ: How react JSX can be strongly typed for state initialized with any value?
   Ans:  useState in latest versions is design as “Generic” type in typescript. 

             Generics are type safe and strongly typed. 
              function useState<Type>(value:Type) 
               {
               }
   Note: React 19x versions are built by using “React Fiber” which uses “TypeScript”              as language. 

3. useContext()
   - Context memory is allocated for parent component.
   - Context memory is accessible to all child components that run with in the context of
     parent. 
   - It is accessible to child at any level of hierarchy. 
   - If child is a uncontrolled component then Context API is required to transport data
     from parent to child. 
   - It requires a context memory to be created.

   a) Create a new context memory 
           let  context = createContext(null);

   b) Configure the context provider in parent
           <context.Provider   value={anyValue}>
               … child component …
           </context.Provider>

   c) Child component can access the context memory by using useContext() hook

           let  ref = useContext(context);
           ref.value;


16/08
======

Context API

 - CreateContext
 - useContext

Ex: context-demo.jsx

import { createContext,  useContext, useState } from "react";

let userContext = createContext(null);

export function Level2(){
    let context = useContext(userContext);
    return(
        <div className="bg-danger text-white p-4 m-4">
            <h4>Level-2 - {context} </h4>
        </div>
    )
}

export function Level1(){

    let context = useContext(userContext);

    return(
        <div className="bg-warning text-danger p-4 m-4">
            <h4>Level-1 - {context} </h4>
            <Level2 />
        </div>
    )
}


export function ContextDemo(){
    const [msg, setMsg] = useState('Welcome');
    function handleNameChange(e){
       setMsg(e.target.value);

    }
    return(
        <div className="container-fluid mx-4 bg-dark text-white p-4 mt-3">
            <div>
                <input type="text" onChange={handleNameChange} placeholder="User Name"/>
            </div>
            <h2>Parent Component - {msg} </h2>
            <userContext.Provider value={msg} >
                <Level1 />
        </userContext.Provider>

            
        </div>
    )
}

FAQ: How data is transported from child component to parent?
Ans: 

       1. You have to establish communication between child and parent. 
               - Event can be used for communication.
               - Event is a message sent by sender to its subscriber in order to notify change.
               - Event follows an “Observer” pattern, which is a communication pattern. 
       
       2. Define a custom event for child component.

               function Child( { eventName } )
               {

               }

       3. Custom event requires a function that triggers action, and sends payload. 

               function Child( {eventName} )
               {
                       function handlerName(){
                              var data = { };
                              eventName(data);         // “e” event argument
                       }
               }

       4. Parent component can access and use child events.

               parentScope
               {
                       <Child  eventName={ parent_functionName } />

                       function  parent_functionName(e) {

                       }


               }

Ex:  context-demo.jsx  [child to parent ]

import { createContext, useContext, useState } from "react";
let userContext = createContext(null);

export function Level2(){
    let context = useContext(userContext);
    return(
        <div className="bg-danger text-white p-4 m-4">
            <h4>Level-2 - {context} </h4>
        </div>
    )
}

export function Level1({ onChildClick }){

    let context = useContext(userContext);

    function handleButtonClick(){
        var data = {Name:'TV', Rating:4.2};
        onChildClick(data);
    }

    return(
        <div className="bg-warning text-danger p-4 m-4">
            <h4>Level-1 - {context} </h4>
            <button onClick={handleButtonClick} className="btn btn-light"> Send Data to Parent </button>
            <Level2 />
        </div>
    )
}


export function ContextDemo(){
    const [msg, setMsg] = useState('Welcome');
    const [msgFromChild, setMsgFromChild] = useState({Name:null, Rating:0});
    function handleNameChange(e){
        setMsg(e.target.value);
    }
    function handleChildClick(e){
        setMsgFromChild(e);
    }
    return(
        <div className="container-fluid mx-4 bg-dark text-white p-4 mt-3">
            <div>
                <input type="text" onChange={handleNameChange} placeholder="User Name"/>
            </div>
            <h2>Parent Component - {msg}  <span className="mx-3"> {msgFromChild.Name} {msgFromChild.Rating}</span> </h2>
            <userContext.Provider value={msg} >
                <Level1 onChildClick={handleChildClick} />
            </userContext.Provider>
            
        </div>
    )
}

18/08
======
Context API
Custom Events

       https://fakestoreapi.com        
       /products 
       /products/categories
       /products/1
       
Ex:  src/fakestore [folder]

1. fakestore-index.jsx

import { useState } from "react";
import { FakestoreProducts } from "./fakestore-products";


export function FakestoreIndex(){


    const [cartItems, setCartItems] = useState([]);
    const [cartItemsCount, setCartItemsCount] = useState(0);

    function handleAddToCartClick(e){
        cartItems.push(e);
        alert(`${e.title}\nAdded to cart`);
        setCartItemsCount(cartItems.length);
    }

    return(
        <div className="container-fluid">
            <header className="border mt-2 border-1 p-4 d-flex justify-content-between">
                <div className="fs-5 fw-bold">Fakestore</div>
                <nav>
                    <div className="input-group">
                        <input type="text" className="form-control" placeholder="Search fakestore" />
                        <button className="btn btn-warning bi bi-search"></button>
                    </div>
                </nav>
                <div>
                    <button data-bs-target="#cart" data-bs-toggle="offcanvas" className="btn btn-warning bi bi-cart4 position-relative"> Your Cart <span className="position-absolute bg-danger badge text-white fs-6 rounded rounded-circle" style={{right:'-10px', top:'-5px'}}>{cartItemsCount}</span> </button>
                    <div className="offcanvas offcanvas-end" id="cart">
                        <div className="offcanvas-header">
                            <h3>Your Cart Items</h3>
                            <button className="btn btn-close" data-bs-dismiss="offcanvas"></button>
                        </div>
                        <div className="offcanvas-body">
                            <table className="table table-hover">
                                <thead>
                                    <tr>
                                        <th>Title</th>
                                        <th>Preview</th>
                                        <th>Price</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {
                                        cartItems.map(item=>
                                            <tr key={item.id}>
                                                <td>{item.title}</td>
                                                <td><img src={item.image} width="50" height="50" /></td>
                                                <td>{item.price}</td>
                                            </tr>
                                        )
                                    }
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </header>
            <section className="mt-4">
                <FakestoreProducts addToCart={handleAddToCartClick} />
            </section>
        </div>
    )
}

2. fakestore-products.jsx


import axios from "axios"
import { useEffect, useState } from "react"

export function FakestoreProducts({addToCart}){

    const [products, setProducts] = useState([{id:0, title:null, price:0, category:null, description:null, image:null}]);

    useEffect(()=>{
        axios.get(`https://fakestoreapi.com/products`)
        .then(response=> {
            setProducts(response.data);
        })
    },[])

    function handleAddClick(product){
        addToCart(product);
    }


    return(
        <div className="d-flex overflow-auto flex-wrap" style={{height:'600px'}}>
            {
                products.map(product=>
                    <div className="card m-2 p-2" key={product.id} style={{width:'200px'}}>
                        <img src={product.image} className="card-img-top" height="120"/>
                        <div className="card-header overflow-auto" style={{height:'120px'}}>
                            {product.title}
                        </div>
                        <div className="card-body">
                            <dl>
                                <dt>Price</dt>
                                <dd>{product.price}</dd>
                            </dl>
                        </div>
                        <div className="card-footer">
                            <button onClick={()=>{ handleAddClick(product) }} className="btn btn-warning bi bi-cart4 w-100"> Add to Cart</button>
                        </div>
                    </div>
                )
            }
        </div>
    )
}

 Task :  Use Context API and collect search string from parent to filter and return products              that contain search string.

                                                            useReducer
- It is used to configure and handle global application state for react application.
- Application state comprises of data accessible across multiple sessions. 

           Application_Start
           {
                   // application state
                   
                   Session_Start
                   {
                       // session state
                   }  // Session_End

           } // Application_End

 - Application state is not easy to debug, test, predict and extend.
 - Hence we need various 3rd party libraries to implement at large scale. 
 - The popular 3rd party JavaScript library is “Redux”.

 19/08
 ======

 4. useReducer

 - It is used to configure global application state.
 - It is available from Application_Start to Application_End.

Reducer Components:
1. Store
       - It is a global application store where the data is kept. 
       - It is global and accessible to all components in application. 
       - It uses a diff mechanism to update the data.

                    previousValue === currentValue => No Change Detected
                    previousValue !== currentValue => Change Detected 

       
2. State
       - It is a local state for component.
       - It can access the data from store and provide to component. 
       
3. Reducer
       - It configures state and actions.
       - State comprises of data accessed from store.
       - Action defines events used to update the data in store. 

4. UI component 
       - It is a consumer.
       - It uses the data accessed from store.
       - It allows changes in data. [ two way binding ]
       - It dispatches the action with new data. 

Implementing Reducer for global store

1. Configure the global store.
   - Typically global store is an object with key and value collection. 
   - It comprises initial state.

Syntax:
           let  initialState = {
                       key : value,
                       key : value
           }

2. Configure a reducer function.
   - Reducer is a function that comprises of state and actions.
   - It can access the initial state.
   - It can configure the events.
   - It can update data into the store.

Syntax:
           function  reducer(state, action)
           {
                   switch(action.type)
                   {
                       case  “A”:
                           return state with modifications;
                       case “B”;
                           return state with modifications;
                   }
           }


3. You can use the reducer in any component 
   - useReducer is a hook that can access reducer function.
   - It will access the data from state.
   - It will dispatch actions and update the data into store.

Syntax:
       const [state, dispatch] = useReducer(reducer, initialState);

       state    => collects data from reducer and uses in component 
       dispatch => triggers an action that sends payload to initialState and updates in store.
Ex:
     reducer-demo.jsx

import { useReducer } from "react"

let initialValues = {
    usersCount: 0
}

function reducer(state, action){
    switch(action.type){
        case "join": 
        return {usersCount: state.usersCount + 1}
        case "exit": 
        return {usersCount: state.usersCount - 1}
    }
}

export function ReducerDemo(){

    const [state, dispatch] = useReducer(reducer, initialValues);

    function handleJoinClick(){
        dispatch({type: "join"});
    }
    function handleExitClick(){
        dispatch({type: "exit"});
    }

    return(
        <div className="container-fluid">
            <h2>Live Users [{state.usersCount}]</h2>
            <iframe width="500" src="https://www.youtube.com/embed/NJVQA10RPuA&quot; height="400"></iframe>
            <div className="mt-2">
                <button onClick={handleJoinClick} className="btn btn-primary bi bi-door-open"> Join </button>
                <button onClick={handleExitClick} className="btn btn-warning mx-2 bi bi-door-closed "> Exit </button>
            </div>
        </div>
    )
}

20/08
======
useEffect
useState
useContext
useReducer

useRef()
  - It configures a reference memory where you can store a value or function.
  - The content in reference memory is used for internal process and not for rendering output in UI.

Syntax:
       let  thread = useRef(null);

       thread.current = value / function;  

useMemo()
   - It is used to memorise a value and provide value across multiple requests.
   - It will avoid unnecessary re-render if value is not changing for a specific duration of time interval. 
   - It can save round trips and improve the performance. 
   - Typically is used for complex computations. 

Syntax:
           let   referenceName =  useMemo(()=>{
                      // handle complex computations 
                     // return a value
            }, [dependency])

useCallback()
   - It is used to memorise a function instead of value.
   - The function configured in memory will execute only when the dependency changes.
   - It avoids unnecessary re-render.

Syntax:
           let  referenceName = useCallback(()=>{

                   // actions to perform when dependency changes

           },[dependency])

                                                            React Routing
- Routing a technique used in web application to configure user and SEO friendly URL’s. 
- User friendly URL allows to query any content directly from URL. 
- SEO friendly URL allows crawlers to identify the exact location in page. 
- Routing enables navigation in SPA. [Single Page Application]
- User can stay on one page and can get access to everything from page. 
- It allows to add new content into page without reloading the page.
- It allows partial post backs. 
- Routing can be configured for application both Client Side and Server Side. 
       a) Server Side routes are used for API or server side application. 
       b) Client Side routes are used for navigation within application UI.

- React uses “react-router-dom” library for configuring client side routes. 
- The latest router-dom library version is 7. It is a complete re-write of its previous versions. 

1. Install react-router-dom for project
           > npm  install   react-router-dom   --save

2. It provides following components 

           <BrowserRouter>        It is a provider for all routes in application. 
           <Routes>                    It is a collection of routes in application.
           <Route>                    It configures individual route.
           <Link>                        It configures a hyperlink used for route navigation.
           <Outlet>                    It defines location to render child content. 

Syntax:
           <BrowserRouter>
                   <Routes>
                           <Route  path=“name | wild-card”   element={ markup | component } >
                                   <Route path=“child”  element={ child markup } />
                           </Route>
                           …
                           …
                   </Routes>
           </BrowserRouter>

           path=“/“                    refers to a request, if it is not for any specific.
           path=“*”                    refers to a request if it is not found. 
           element                    refers to custom markup or any component that renders markup. 
           Syntax:
           <Route   path=“/“    element={ <div> Home </div> } />
           <Route   path=“/“    element={ <Home /> } />

           <Link to=“pathName”>  Text | Image </Link>

Ex:  portfolio-index.jsx

import { BrowserRouter, Link, Route, Routes } from "react-router-dom";
import { EMICalculator } from "../components/emi-calculator/emi-calculator";
import { CarouselDemo } from "../components/carousel-demo/carousel-demo";


export function PortfolioIndex(){
    return(
        <div className="container-fluid">
            <BrowserRouter>
                <header className="text-center">
                    <div className="fs-2"> John </div>
                    <div className="fs-5"> React Developer </div>   
                    <div className="fs-5"> My Projects </div> 
                    <nav>
                        <span> <Link to="/">Home</Link> </span>
                        <span className="mx-5"> <Link to="/emi"> EMI Calculator </Link> </span>
                        <span> <Link to="/carousel"> Carousel  </Link> </span>
                    </nav>
                </header>            
                <section>
                    <Routes>
                        <Route path="/" element={<div>Hello ! I am John React Developer.</div>} />
                        <Route path="emi" element={<EMICalculator />} />
                        <Route path="carousel" element={<CarouselDemo />} />
                        <Route path="*" element={<div><h3>Requested Path Not Found </h3></div>} />
                    </Routes>
                </section>
            </BrowserRouter>
        </div>
    )
}

21/08
======

Routing
<BrowserRouter>
<Routes>
<Route>
<Link>
<Outlet>

Route Parameters:
 - A route parameter allows to query any content in a component.
 - You can transport data from one component to another using route parameter.

Syntax: Without route params 
   https://www.amazon.in/products?category=electronics&type=mobiles&brand=apple

Syntax: With route params
   https://www.amazon.in/products/electronics/mobiles/apple

 - You have to configure route with parameters.
      <Route  path=“name/:param1/:param2…”    element= { <component /> } />

- Actual values are passed from URL 
       http://localhost:port/name/value1/value2

       Note: Every parameter is a required parameter and has order dependency. 
- You can access and use route parameters by using “useParams()” hook. It returns an object with key and value collection. 

       let  params = useParams();      //   { param1 : value1, param2: value2 }
       params.param1    = value1
       params.param2 = value2

FAQ: What is difference between “Absolute” & “Relative” path ?
Ans:  Relative path is used within the context of a parent. It is for child routes.

                           http://localhost:port/home
                   <Link  to=“details”> Details </Link>
                           http://localhost:port/home/details
    Absolute path is not relative to any current context, it sets a new path by replacing the
    existing path.
                    <Link  to=“/details”> Details </Link>

                   to = “details”            // relative
                   to = “/details”            // absolute

22/08
======
Configuring Child Routes:
  - A route can have collection of child routes.
  - Child routes are with in the context of parent. 
  - Parent keeps all child routes relative to parent. 

Syntax:
           <Route   path=“parent”   element={<Parent />} >
                   <Route path=“child” element={ <Child /> } />
                   …
           </Route>
  - Child routes require “<outlet>”, which specifies the target location where resulting markup is rendered. 

FAQ: Can we have multiple route outlets? 
Ans:  Yes. React allows multiple route outlets. 

FAQ: How to navigate dynamically?
Ans:  By using “useNavigate()” hook.
   Syntax:
               let  navigate = useNavigate();
               navigate(“/path”);

FAQ: What are search params?
Ans: It refers to “Query String”. 
       A route can use route parameter along with Query string. 
       localhost:port/path/param?key=value&key=value

FAQ: Why we need search params?
Ans:  Search parameters are required to collect data from a “form” and submit to any component both client side or server side.
        Form submits its data by default as Query String on “GET” method.

Syntax:
           <form action=“/route-path”>
            </form>

FAQ: How to access search parameters?
Ans:  By using “useSearchParams()” hook. 

Syntax:
           const [params] = new useSearchParams();
           params.get(“key”);

FAQ: How to access Search params using actual DOM techniques? 
Ans:  By using window “URLSearchParams()”  object.
           let  ref = new URLSearchParams(location.search);
           ref.get(“key”);

Ex:
 1. Add components
       shopping-search.jsx
       shopping-search-results.jsx

2. Search comprises of form submit data to results.
3. Results collects query string using useSearchParams().
4. Update  shopping-index.jsx  with routes.

FAQ: How to restrict access to any specific route?
Ans: You can use various state management techniques or tokens. 
       You have to implement any authentication process to restrict access. 
       a) Session Storage
       b) Local Storage
       c) Cookies
       d) JWT  etc.

CRUD - JSON Server

25/08
======
1. Install JSON-Server for your project

           > npm  install  json-server  -g              [ Global ]
           > npm  install  json-server                   [ Local ] 

2. Go to project Root folder and add new file  “db.json”

3. Add following  collections into db.json

           admin        
           - admin_id
           - password 

           users
           - user_id
           - user_name
           - password
           - email

           categories
           - category_id
           - category_name
       
           videos
           - title
           - description
           - url    
           - likes
           - dislikes
           - views
           - comments
           - category_id

Ex:
{
    "admin": [
        {
            "id": 1,
            "admin_id": "john_admin",
            "password": "john@123"
        }
    ],
    "users": [
        {
            "id":1, 
            "user_id": "david_nit",
            "user_name": "David", 
            "password": "david1",
            "email": "david@outlook.com"
        }
    ],
    "categories": [
        {
            "id": 1,
            "category_id": 1,
            "category_name": "Java"
        },
         {
            "id": 2,
            "category_id": 2,
            "category_name": "React"
        },
         {
            "id": 3,
            "category_id": 3,
            "category_name": "AWS"
        }
    ],
    "videos": [
        {
            "id": 1,
            "title": "Java Stream API",
            "description": "Java Tutorials",
            "url": "https://www.youtube.com/embed/U2PiMIS75jU&quot;,
            "likes": 200,
            "dislikes": 0,            "views": 500,
            "comments": "Thank you",
            "category_id": 1
        }
    ]
}

4. Go to “package.json” and add shortcut for executing JSON server and start API 

      “scripts”:
       {
         …,
         “api”: “npx  json-server  db.json  --watch  --port=3000”
       }

5. You can start API every time using following command
       > npm  run  api 

API End Points:
   GET     http://localhost:3000/admin
   GET        http://localhost:3000/users
   POST    http://localhost:3000/users
   GET        http://localhost:3000/categories
   GET        http://localhost:3000/videos 
   POST    http://localhost:3000/videos 
   PUT        http://localhost:3000/videos/id [edit]
   DELETE    http://localhost:3000/videos/id [delete]

Note: You can test API end points using any debugger like
           a) postman
           b) fiddler 
           c) swagger etc.


26/08
======

React Cookie Library
 - Cookie is a simple text document that can be used for storing client details. 
 - Cookie can be 
   a) In Memory [Temporary]
   b) Persistent [Permanent] 
 - Cookie can be persistent when set with expiry date.

1. Install React Cookie library for project
           > npm  install   react-cookie  --save 

2. Import “useCookies()” hook into component  and configure cookie
       import { useCookies } from ‘react-cookie’;
       const [ cookies, setCookie, removeCookie ] = useCookies([ ‘name’ ]);

       cookies            : It is used to access cookie value.
       setCookie        : It configure a value into cookie and defines expiry. 
       removeCookie: It removes specified cookie.
   Note: Cookies must be enabled in your browser. You can check by using JavaScript
            “navigator” object.
             > navigator.cookieEnabled  => returns true / false

3. Save data into cookie by using setCookie()
           setCookie(‘name’, value, { expires : ‘date’ });

4. Access cookie   
           cookies[‘name’]

5. Remove cookie
           removeCookie(‘name’);

Note: Cookie is provided as a service, It requires a provider for locating values in memory
        and injecting into components. 
        You have to configure provider in “main.jsx”. 

Syntax:     main.jsx

       import  { CookiesProvider }  from ‘react-cookie’;

       <CookiesProvider>
            <YourIndexComponent />
       </CookiesProvider>


28/08
======
Formik Edit Action:
 - Edit requires existing details to display.
 - Initial values will not allow to re-initialize with new values. 
 - You have to set “enableReinitialize” to true. 
 
Syntax:
   const formik = useFormik({
         initialValues : {
               id : videos.id,
               title: videos.title
         },
        onSubmit: (values) => { },
        enableReinitialize: true
   })

  - Initialized values are binded with elements using “formik.values”

    <input type=“text”  value={formik.values.title}  onChange={ formik.handleChange } />

Note: Create  edit, delete actions a relative actions [relative path] of admin dashboard.
    Add validation for login, edit and add video form.


29/08
======

React Material UI 
- MUI provides comprehensive suite for building interactive UI.
- It is designed with React components, hence it is more native to React. 
- MUI provides various products like
       a) MUI
       b) MUI-X
       c) Toolpad 
       d) Templates etc.

- MUI-Core is free and provides a component library for building React applications.
- MUI latest version is a complete re-write of its earlier versions. 
- Latest MUI uses new “@emotion” library. 
- It is available for React 18x and higher versions. 

Setup MUI for project:

1. Install the following libraries for project
           > npm install @mui/material @emotion/react @emotion/styled  --save

2. Import the relative component  and customize 

Note: Components are controlled and use “props”, go to “API” and check all properties.

1/09
=====

React Redux

- Redux is a JavaScript library for global application state.  
- It provides a toolkit for all JavaScript libraries and frameworks.
- The toolkit enables easy tracking, debugging and testing of application state.
- It makes global application state predictable.

1. Install Redux for React
   > npm install @reduxjs/toolkit   react-redux --save

2. Install React Redux Dev tools for your browser.

3. Create and configure a slicer for Redux 

   Slicer
   - It configures a slicer for application.
   - It handles initial state.
   - It configures a reducer with actions and definition.
   - Actions collect the payload and update into initial state.
   - Actions are dispatched from any component. 
   - Slicer maps to actions in component. 
   - Redux slicer is configured using “createSlice()” method.

Syntax:  slicer.jsx
       const  initialState = { data : value }
    - Configure the slicer 

Syntax:
       const slicerName = createSlice({
            name: “slice-name”,
            initialState,
            reducers : {
                   action1: (state, action) => { },  // action.payload  collects data from component
                   action2: (state, action) => { }   // update data into initialState, by using “state”.
            }
       })

    - Export the actions and slicer from module 
      export const  { action1, action2} = slicerName.actions;
      export default slicerName.reducer;

    - Every slicer is defined with 2 components
               a) reducer
               b) actions

  4. Create a store and import the slicer 

    Store:
       - It comprises of initialState and finalState.
       - It uses a diff mechanism to track changes in data and update data.
       - It is a global store for providing data to components across all sessions from
         application start to end.

Syntax: store.jsx

       import { configureStore }  from  “@reduxjs/toolkit”;
       import  slicer from  “slicer”;    // slicer jsx
       export default configureStore({ 
           reducer : slicer                // slicer have data and actions
       })

   5. Configure Provider in “main.jsx”

    Provider:
        - It locates the data in memory.
        - It can inject into any component.
        - It makes the data available only for components that run within the provider scope.

                       “main.jsx”

       import  { store }  from  “store.jsx”;
       import  { Provider } from “react-redux”;

       <Provider store={ store } >
           <IndexComponent />
       </Provider>

     6. You have to dispatch the data from component 

    - Import  useDispatch from “react-redux” library.
    - Import  the actions from slicer actions.

                       component.jsx

      import { action1 }  from  “./slicerName”;      // slicer.jsx
      import { useDispatch} from “react-redux”;
      const dispatch = useDispatch()

       function handleEvent()
       {
            dispatch(action(data));     // data refers to data coming from component & used as
       }                                            payload

    7. Import store from any component and access the global store. 
        import  { store }  from  “store” ; // store.jsx
        store.getState().storeData      // data updated into global state can be accessed


2/09
=====

React Class Components

- JavaScript Classes
- Class Declaration & Expression
- Class Members
   a) Property
   b) Accessor
   c) Method
   d) Constructor
- Inheritance [extends] 
- Prefixes “_, #”
- Static members [ static keyword ]

1. A class component must extend  “React.Component” or “React.PureComponent”.

       export class Component extends React.Component | React.PureComponent
       {

       }

FAQ: What are pure & impure functions in JavaScript?
Ans:  A pure function returns same result across multiple requests.
       An impure function returns different result even when the parameter is same across 
       multiple requests. 

Ex: Impure 
   <script>
     var c = 0;
     function Counter(a){
          c++;
          return c + a;
     }
    document.write(Counter(10) + "<br>");
    document.write(Counter(10) + "<br>");
    document.write(Counter(10) + "<br>");
    document.write(Counter(10) + "<br>");
</script>

  FAQ: What is a pure component?
  Ans : It returns same across multiple requests.
         It can change only when the dependency changes.
 
2. Component requires a constructor that calls super constructor. 

     export class Component extends React.Component
     {
              constructor() {
                super();
              }
     }

3. Component class can return JSX element by using “render()” method of base class. 

     export class Component extends React.Component
       {
           constructor() {
               super();
           }
           render() {
                 return (
                           <div> JSX </div>
                          );
            }
       }

State in Class component:
 - Class components are stateful.
 - React Component base provides a state for custom component. 
 - You have to configure state while creating instance of class. 

Syntax:
           constructor()
           {
               super();
               this.state = { key:value, .. }
           }

           <p> { this.state.key } </p>

  - State in class is object type with key and value collection. 
  - You can set state by using “this.setState()” method. 
  - You can set state only on mount phase or on any specific event.
  - Component phases in class are defined using following methods
   
           a) componentWillMount()
           b) componentDidMount()
           c) componentDidUpdate()
           d) componentWillUnmount() 

Ex:  customer-login.jsx

import React from "react";

export class CustomerLogin extends React.Component
{
      constructor(){
          super();
          this.state = {
              title: "Class Components",
              categories: ['All', 'Mobiles', 'Watches']
          }
      }
      componentDidMount(){
         this.setState({title: "Select Category"})
      }
      render(){
         return(
            <div className="container-fluid p-4">
                <h2>{this.state.title}</h2>
                <select>
                    {
                        this.state.categories.map(category=>
                            <option key={category}>{category}</option>
                        )
                    }
                </select>
            </div>
         )
      }
}

 - Data Binding            ]
 - Style Binding        ] Same as in function component
 - Class Binding        ]

Event Binding:
   - Class components use method as subscriber.
   - Subscriber defines the actions to perform. 
   - All events are derived from “SyntheticEvent” base.
   - If your events are using state then it is mandatory to binding even handler with current
     class memory.
   - It requires “bind()” method. 

Ex:
import React from "react";

export class CustomerLogin extends React.Component
{
      constructor(){
          super();
          this.state = {
              title: "Class Components",
              msg: ""
          }
          this.handleInsertClick = this.handleInsertClick.bind(this);
      }
      componentDidMount(){
         this.setState({title: "Select Category"})
      }

      handleInsertClick(e){
         this.setState({msg: `${e.target.value} Clicked`});
      }
      handleDeleteClick(e){
         this.setState({msg: `${e.target.value} Clicked`});
      }

      render(){
         return(
            <div className="container-fluid p-4">
                <h2>{this.state.title}</h2>
                <button onClick={this.handleInsertClick} value='Insert'>Insert</button>
                <button onClick={this.handleDeleteClick.bind(this)} value='Delete'>Delete</button>
                <p>{this.state.msg}</p>
            </div>
         )
      }
}

3/09
======

Class Props
- Class Component
- Pure & Impure 
- State in Class 
- Style Binding, Class Binding, Data Binding 
- Event Binding in Class
- bind() method 

FAQ: How to configure event with state without bind() method?
Ans:  You have to return the event handler with default arguments, which allows to us
        the class memory.

       <button onClick={ (e) => { this.handleClick(e) } }>  Click </button>

import React from "react";

export class CustomerLogin extends React.Component
{
      constructor(){
          super();
          this.state = {
              title: "Class Components",
              msg: ""
          }
          this.handleInsertClick = this.handleInsertClick.bind(this);
      }
      componentDidMount(){
         this.setState({title: "Select Category"})
      }


      handleInsertClick(e){
         this.setState({msg: `${e.target.value} Clicked`});
      }
      handleDeleteClick(e){
         this.setState({msg: `${e.target.value} Clicked`});
      }
      handleUpdateClick(e){
         this.setState({msg: `${e.target.value} Clicked`});
      }

      render(){
         return(
            <div className="container-fluid p-4">
                <h2>{this.state.title}</h2>
                <button onClick={this.handleInsertClick} value='Insert'>Insert</button>
                <button onClick={this.handleDeleteClick.bind(this)} value='Delete'>Delete</button>
                <button onClick={(e)=> {this.handleUpdateClick(e)} } value='Update'> Update </button>
                <p>{this.state.msg}</p>
            </div>
         )
      }
}


- Connecting with API is same, you can use “axios”. 
- Handling forms with validation requires “formik” components and “yup” library.
- You can’t use any library with hooks.

Ex: API

import React from "react";
import axios from "axios";

export class CustomerLogin extends React.Component
{
      constructor(){
          super();
          this.state = {
k              categories: []
          }
          
      }
      LoadCategories(){
         axios.get('https://fakestoreapi.com/products/categories')
         .then(response=>{
             this.setState({categories: response.data});
         })
      }
      componentDidMount(){
          this.LoadCategories();
      }


      render(){
         return(
            <div className="container-fluid p-4">
               <ul>
                  {
                     this.state.categories.map(category=><li key={category}>{category}</li>)
                  }
           </ul>

            </div>

      )

      }
}

Ex:  Form

import React from "react";
import axios from "axios";
import { Field, Form, Formik } from "formik";

export class CustomerLogin extends React.Component
{
      constructor(){
          super();
          this.state = {
              
          }
          
      }
      
      componentDidMount(){
         
      }



      render(){
         return(
            <div className="container-fluid p-4">
               <h3>Register</h3>
               <Formik initialValues={{UserName:'', Mobile:''}} onSubmit={(user)=>{console.log(user)}} >
                  <Form>
                     <dl>
                        <dt>User Name</dt>
                        <dd> <Field type="text" name="UserName"></Field> </dd>
                        <dt>Mobile</dt>
                        <dd> <Field type="text" name="Mobile"></Field> </dd>
                     </dl>
                     <button type="submit">Register</button>
                  </Form>
               </Formik>
            </div>
         )
      }
}

Controlled Class Components:
   - Controlled component is controlled by the data from parent. 
   - It uses “properties”.
   - Class comprises of built-in “props” object.

Syntax:
       render()
       {
         return( 
           <div> { this.props.key } </div>      // key is a dynamic name
         )
       }

       <Component key={value} />

Ex:  controlled-component/nav.jsx

import React from "react";

export class Nav extends React.PureComponent
{
     constructor(){
         super();
     }
     render(){
        return(
            <nav className="d-flex justify-content-between p-2 border border-1">
                <div className="fs-3 fw-bold">{this.props.title}</div>
                <div>
                    {
                        this.props.navItems.map(item=><span className="mx-3" key={item}>{item}</span>)
                    }
                </div>
                <div>
                    <span className="bi bi-person"></span>
                    <span className="bi bi-cart mx-2"></span>
                </div>
            </nav>
        )
     }
}

                                                 TypeScript Language
Issues with JavaScript:
   - It is not strongly typed.
   - It is not implicitly strictly typed.
   - It is not an OOP language.
   - It supports few features of OOP.
   - Code level security issues.
   - Extensibility issues. 

What is TypeScript?
 - Typescript is a language introduced by Microsoft. 
 - “Anders Hejlberg” is the architect of Typescript. [ well known for C# language ].
 - It is strictly typed superset of JavaScript. 
 - It is used to build large scale applications. 
 - It is build in Typescript.
 - It is native to OS services. 
 - It is strongly typed.
 - It is implicitly strictly typed. 
 - It must be trans compiled into JavaScript. 

     Developer => writes in TypeScript => trans compiled into => JavaScript => Browser

TypeScript Architecture 
Pasted Graphic.png
Install TypeScript for your device

- Open command prompt or terminal and run the command
       > npm  install  -g  typescript 

- Check the version
       > tsc  -v

04/09
=======
- What is TypeScript?
- Features of TypeScript
- TypeScript Architecture 

1. Core Compiler 
   - It provides various components for handling input, output, parsing etc.
     core.ts, program.ts, parser.ts, scanner.ts, emitter.ts etc.

2. Standalone Compiler
   - It trans compiles Typescript into JavaScript.
     tsc.ts

3. Language Service
   - It provides all services for executing programs and compiling according to flow.
     services.ts

4. TsServer 
   - It hosts the program, handles request and response. 
     server.ts 


5. VS Shim 
   - It makes the typescript program platform neutral.
   shims.ts

6. Managed Language Service
   - It is a library of functions and values suitable for all platforms. 
   - It makes functions cross platform. 

   > npm  install   typescript -g
   > tsc -v 

Create a new typescript project:

1. Create a new folder for project on your device 

           D:\tsproject

2. Open project folder in VS code 

3. Run the command 

           > npm init  -y            // package.json
           > tsc  -init                // tsconfig.json   [ tslint.json - deprecated ] 

4. Add “index.ts” into root  folder 

           console.log(“Welcome”);

5. Trans compile Typescript into JavaScript

           > tsc  index.ts        => generates  “index.js”

6. Run index.js

           > node  index.js


TypeScript Language:

1. Variables
   - Same as in JavaScript.
   - Uses var, let, const.
   - TypeScript variable requires data type to define, as it is strongly typed.

Syntax:
            let  variableName : dataType = value;

   - It uses all JS data types.
           a) Primitive Type
                   number
                   string
                   boolean 
                   null
                   undefined
                   symbol 
           b) Non Primitive
                   Array()
                   Object
                   Map
           c) Date & Regular Expression 

   - TypeScript supports “Type Inference”.
   - The data type will be determined according to the value initialized. 

           let x = 10;            // x is number
           x = “A”;                // invalid 
           let x:number;
           x=10;

           x=“A”;                // invalid 

   - If type is not defined and value is not initialized then the default is “any” type.

           let x;                // x is any
           x = 10;            // x is number
           x = “A”;            // value x is string

   - TypeScript supports “Union” of types.
   - Union allows to handle multiple types. 

           let x :number | string | boolean;
           x = 10;
           x = “A”;
           x = true;
           x = undefined;        // invalid
           
   Ex:
           var name : string | null = prompt(“Enter Name”);

   - All number methods, string functions are same.
   - Handling undefined and null are same.

2. Handling TypeScript Non Primitive Types

   a) Array
       - It can use meta character “[ ]” or “Array()” constructor.
       - Typescript array can restrict to same type of value collection or allow various types. 
Syntax:
         let  values:number[]   = [ ];
         let  values:string[]   = new Array();

         let  values:any[] = new Array();
         let  values:any[] = [ ];

      - “Array()” will not allow to initialize different types of value even when the data type is
        configured as “any”.
     -  You can assign different types of values.
     - Initialization of values depends on the first element data type.
     - Array memory with “[]” meta character allows initialization and assignment of various 
       types when data type configured as any. 
     - If a collection allows assignment and initialization of various types then it is known as 
       a “Tuple”.
     
       Syntax:
                   let values:any[] = [ ];
     - TypeScript supports union of array types.
           let  values:string[ ] | number[]  = [ ];
   
     - You can’t initialize both types, you can only assign both types.
     - Initialization must be only for one specific type.
     - All array methods are same as in JS.

   b) Object

05/09
======

TypeScript
Variables
Data Types

Object Type:
     - Purpose is same as in JS.
   - Typescript object is configured with strongly typed structure. 
   - Keys are strongly typed. 

Syntax:
    var obj : { key: type, key: type } = {  };

   - Every key is a required key by default.    - You can’t add a new key, which is not defined in structure. 
   - Typescript provides a null reference character “?”, which is used to configure optional keys.
   
Syntax:
    var obj : { key?: type, key: type } = { };

Ex:

let product:{Id:number, Name:string, Stock:boolean, Price?:number} = {
    Id : 1, 
    Name: "TV",
    Stock: true,
    Price: 45000
}
product.Name = "Samsung TV";

if("Price" in product){
    console.log(`Id=${product.Id}\nName=${product.Name}\nStock=${product.Stock}\nPrice=${product.Price}`);
}
else {
    console.log(`Id=${product.Id}\nName=${product.Name}\nStock=${product.Stock}`);
}

   - Typescript supports “readonly” keys.
   - It will not allow to assign a new value after initialization. 

Syntax:
   var obj : {key? : type,  readonly key: type } = { } 

Ex:

let product:{Id:number, Name:string, Stock:boolean, readonly Price?:number} = {
    Id : 1, 
    Name: "TV",
    Stock: true,
    Price: 45000
}
product.Name = "Samsung TV";
product.Price = 56000; // invalid - Price is readonly

if("Price" in product){
    console.log(`Id=${product.Id}\nName=${product.Name}\nStock=${product.Stock}\nPrice=${product.Price}`);
}
else {
    console.log(`Id=${product.Id}\nName=${product.Name}\nStock=${product.Stock}`);
}

   - All object manipulations are same as in JS.
   - Object can configure rules for both data and logic. 
   - Object can defined optional and readonly logic as function type.
   - A function type can be void or with specific data type.

Syntax:
   var obj : { key: type, key?():void, key():number } = { } 

Ex:
let product: {Name:string, Price:number, Qty:number, Total?():number, Print():void} = {
    Name: "TV",
    Price: 56000,
    Qty: 2,
    Total: function(){
        return this.Qty * this.Price;
    },
    Print: function(){
        console.log(`Name=${this.Name}\nPrice=${this.Price}\nQty=${this.Qty}\nTotal=${this.Total()}`);
    }
}
product.Print();

Collection of objects:
   - JavaScript can handle array of object type data.
   
               [  { }, { } , .. ]

   - Typescript can restrict object type array with strongly typed data. 
   - You can configure a structured collection in typescript. 

Ex:

let products: {Name:string, Price:number}[] = [
    { Name: "TV", Price: 34000 },
    { Name: "Mobile", Price: 12000 }
];


Syntax:
    const collection : {key: value, key:value}[ ] = [ { }, { } ];

Map Type
   - JS map is a collection of key and values. 
   - JS map can have any type key and value. 
   - Typescript Map is “Generic” type. 
   - You can restrict the key and value type.

Syntax:
     let  data : Map<key_type, value_type> = new Map();

     let data : Map<number, string[]> = new Map();
     let data : Map<any, any> = new Map();

   - All map methods are same.

Regular Expression Type:
   - Typescript provides a special data type “RegExp” to restrict a pattern.
   - Patterns are configure using meta characters and quantifiers enclosed in “/ /“.

Syntax:
        let pattern : RegExp = / \+91\d{10} /;
   - Regular expression is verified by using “match()” method.
       
        if (value.match(pattern))
        {
        }

Ex:
let pattern:RegExp = /\+91\d{10}/;
let mobile:string = "9876543211";

if(mobile.match(pattern)){
    // valid
}
else 
{
    // invalid
}

Date Type
   - Date and time values can be configure using “Date” data type
   - It requires a Date() constructor to allocate memory for date and time values.
Syntax:
       let  departure: Date = new Date(“yy-mm-dd hrs:min:sec.millSec”);
   - All date methods are same as in JS.

Ex:
let today:Date = new Date();
console.log(today.toLocaleDateString());


JavaScript Operators        ]   same in typescript
JavaScript Statements        ]   same in typescript 

Typescript Functions:
   - Declaration and expression is same as in JS.
   - Function and parameters are strongly typed.

Syntax:
       function Name(param: type) : void | type
       {
       }

       function Name(…param:any[])
       {
       }

   - You can restrict rest parameter to specific type.
   -  Function parameter can be optional. You can use “?” Null reference character. 
   -  All optional parameters must be last in formal list.
   - A required parameter can’t precede optional parameter. 

Syntax:
function Details(id:number, name:string, price?:number):void
{
}

function Addition(a:number, b:number):number 
{
     return a + b;
}

function Product(...details:any[])
{
}

   - All function concepts are same in Typescript.
   - React component function type will be “JSXElement”.


8/09
=====

TypeScript OOP


1. Contracts
   - A contract defines rules for any component.
   - A contract configures reusable and extensible rules. 
   - Technically contract refers to an “Interface”. 
   - A contract must contain only rules not the implementation. 

Syntax:
       interface IName
       {
           rule: type;
           rule: type = value; // invalid
       }

   - A contract must contain only declaration and not the definition.
   - A contract can contain optional rules configured using null reference character [ ? ].
   
Syntax:
       interface Name
       {
           rule?: type;
       }
   
   FAQ: Why a contract can have optional rules?
   Ans: To configure “goal”. 
           “Goal” is not time bound and not always achievable. 
   
   - A contract can have “readonly” rules.
   - It will not allow to assign after initialization. 

Syntax:
       interface Name
       {
           readonly rule: type;
       }

   - A contract can configure rules for methods or actions. 
   - Rule for method defines return type or void.
   - It can’t have definition for method. 
   - It can have optional method. 

Syntax:
       interface Name
       {
           rule?():void | type;
       }

   - You can extend and reuse a contract by using “inheritance”.
   - Contract will not support aggregation, as there is no constructor in contract. 
   - A contract can extend multiple contracts. 

Syntax:
       interface  FinalContract extends Contract1, Contract2
       {
       }
       
       let obj : FinalContract = {  }         // must implement rules from all contracts [1, 2, final] 
       
   - If multiple contract have identical members then it implements only the first occurrence 
     contract member. 

Ex:
interface ICategory
{
     CategoryName:string;
}
interface IVendor 
{
     VendorName:string;
}



interface IProduct extends ICategory, IVendor
{
     Name:string;
     readonly Price:number;
     Stock:boolean;
     Rating?:number;
     Qty:number;
     Total():number;
     Print?():void;
}
let product:IProduct = {
     Name: "TV",
     Price: 34000,
     Stock: true,
     Rating: 3.5,
     CategoryName: "Electronics",
     VendorName: "Reliance Digital",
     Qty: 2,
     Total: function(){
          return this.Qty * this.Price;
     },
     Print:function(){
          console.log(`Name=${this.Name}\nPrice=${this.Price}\nRating=${this.Rating}\nTotal=${this.Total()}\nCategory=${this.CategoryName}\nVendor=${this.VendorName}`)
    }

}
product.Name = "Samsung TV";
product.Print();

2. Components
       - A class is technically configured as component.
       - You can declare a class or use it as expression. 
       - Class members are same as in JS
           a) Constructor
           b) Method
           c) Property
           d) Accessor
       - Class can configure static and non static members. 
           a) Static    : It refers to continuous memory
           b) Non Static: It refers to discreet memory
       - Typescript class member can be configure with access modifiers 
           a) public
           b) private 
           c) protected 

       public    :  It is accessible from any location.
                      You can access within the class.
                      You can access outside class.
                      You can access using super class object or derived class object.

       private        : It is accessible only within the class.

       protected    : It is accessible within the class.
                        You can access outside class but only in derived class and only by using
                        derived class reference. 

   Note: The default access modifier set to members is “public”.

Ex:

class Product
{
     public Name:string = "";
     private Price:number = 0;
     protected Stock:boolean = false; 
     Print(){
          this.Name;
          this.Price;
          this.Stock;
     }
}
class Derived extends Product
{
     Print() {
          let obj = new Derived();
          obj.Stock; // protected
     }
}

9/09
=====

Contracts - Interface 

- Reuse Contracts
- Rules for properties & methods
- Read Only Rules
- Optional Rules
- Extending Contracts

Components - Class
- Class Configuration
- Class Members
       Property, Method, Accessor, Constructor 
- Static Members
- Access Modifiers
       public, private, protected 

Class using Contract: 
     - A class can be configured with rules. 
   - Rules are defined using contract.
   - Class can implement a contract. 
   - Class can implement multiple contracts. It supports multiple inheritance of contracts. 
   - It is mandatory to implement all required rules of contract.
   - You can add more features into class in addition to rules defined in contract. 
   - Class is a program template hence it allows customization. 

Syntax:
       class Name implements  Contract1, Contract2
       {
           
       }

Ex:
interface IProduct
{
     Name:string;
     Price:number;
     Qty:number;
     Total():number;
     Print():void;
}
interface ICategory
{
     CategoryName:string;
}
class Product implements IProduct, ICategory
{
     public Name:string = "";
     public Price:number = 0;
     public Qty: number = 0;
     public CategoryName: string = "";
     public Total(): number {
          return this.Qty * this.Price;
     }
     public Print(): void {
          console.log(`Name=${this.Name}\nPrice=${this.Price}\nQty=${this.Qty}\nTotal=${this.Total()}`);
     }
}
let tv = new Product();
tv.Name = "Samsung TV";
tv.Price = 35000;
tv.Qty = 2;
tv.CategoryName = "Electronics";
tv.Print();

Templates in OOP:

   - A template comprises of pre-defined business logic which you can implement and customize according to the requirements.
   - Templates are used in various situations like
           a) Rollouts
           b) Implementation of secured modules 
   - Templates hide the structure and provide only implementation, which is known as 
     “abstraction”.
   - You can configure a template as “abstract” class. 
   - A class marked with abstract comprises of few members, which are already implemented 
     and few others require implementation. 
   - The incomplete properties and methods, which need to be implemented are marked as
     “abstract”. 
   - You can’t directly create an object for abstract class, as it is incomlete class. 
   - You have to extend the abstract class and implement the functionality. 

Syntax:
       abstract class Name  implements Contract
       {
            abstract Property: type;
            abstract Method(): type;
            nonAbstract Property: type;
       }
       class Component extends Abstract_Class
       {
           // implement abstract members
       }

Ex:
interface ProductContract
{
     Name:string;
     Price:number;
     Qty:number;
     Total():number;
     Print():void;
}
abstract class ProductTemplate implements ProductContract
{
     public Name: string = "";
     public Price: number = 0;
     public Qty: number = 1;
     abstract Total(): number;
     abstract Print(): void;
}
class Product extends ProductTemplate
{
     Name = "Samsung TV";
     Price = 450000;
     Qty = 2;
     Total() {
          return this.Qty * this.Price
     }
     Print(){
          console.log(`Name=${this.Name}\nPrice=${this.Price}\nQty=${this.Qty}\nTotal=${this.Total()}`)
     }
}

let tv = new Product();
tv.Print();

Generics, Enum, Module, Namespace

10/09
=======

- Interface                Contract
- Abstract Class        Template
- Class                    Component
- Class Inheritance, Aggregation 
- Polymorphism 

Generics
   - Generic refers to “type safe”.
   - A type safe member can handle any type of data and make it strongly typed after knowing the data type. 
   - Type safe can be defined for
           a) function
           b) function parameter  & return
           c) class 
           d) property 
           e) method

Syntax: Generic Function & Parameter 

           function Name<Type>( param:Type) : Type
           {
           }

Ex:
interface IProduct
{
     Name:string;
     Price:number;
}
function FetchData<T>(data:T) : T
{
     return data;    
}
console.log(FetchData<number>(20));
console.log(FetchData<string>("A"));
console.log(FetchData<string[]>(["A", "B"]));
console.log(FetchData<IProduct>({Name: 'TV', Price:50000}));
console.log(FetchData<IProduct[]>([{Name:'Mobile', Price:21000}, {Name:'Watch', Price: 23400}]));

Ex: Generic class & property

interface IMongoDB
{
     url:string;
}
interface IMySQL
{
     host:string;
     user:string;
     password:string;
}
class Database<T>
{
     public ConnectionString:T|null = null;
     public Connect():void {
          Object.keys(this.ConnectionString).map(key=>{
               console.log(`${key} : ${this.ConnectionString[key]}`);
          })
     }
}

// Project-1 Database MySQL

let mysql = new Database<IMySQL>();
mysql.ConnectionString = {host: 'localhost', user:'root', password:'1234'};
mysql.Connect();

// Project-2 Database MongoDB

let mongo = new Database<IMongoDB>();
mongo.ConnectionString = {url: 'mongodb://127.0.0.1:27017'};
mongo.Connect();

Ex: Generic Method

interface IMongoDB
{
     url:string;
}
interface IMySQL
{
     host:string;
     user:string;
     password:string;
}
class Database
{
    public Connect<T>(connectionString:T){
       for(var key in connectionString){
           console.log(`${key}: ${connectionString[key]}`);
       }
    }
}

let mongo = new Database();
mongo.Connect<IMongoDB>({url: 'mongodb://localhost:27017'});

Note: Generic Constructors are supported in TypeScript. 
         A constructor can’t be generic but its parameter can be generic. 

Ex: Generic constructor parameter

interface IMongoDB
{
     url:string;
}
interface IMySQL
{
     host:string;
     user:string;
     password:string;
}

class Database<T>
{
    constructor(connectionString:T){
       for(var key in connectionString){
           console.log(`${key}: ${connectionString[key]}`);
       }
    }
}

let mongo = new Database<IMongoDB>({url:"mongodb://localhost:27017"});
let mysql = new Database<IMySQL>({host:'localhost', user:'root', password:'123'});


Enumeration [ Enum ]
   - Enum Is a collection of constants. 
   - Constants are initialized with a value, which remains constant across requests. 
   - You can assign a new value, but can use the constant value. 
   - Enum constants can be
       a) number
       b) string & 
       c) expression 
   - Enum can’t have boolean as constant. 
   - Enum can initialize values automatically for numeric constants.
   - Next value depends on the previous value. If there is no previous value then it starts with
     zero “0”.

Syntax:
       enum Name
       {
         Key = value,
         Key,
       }
       Name.key                // returns value
       Name[value]            // returns key - reverse mapping

   - Enum with string can’t auto implement the values.
   
       enum Name
       {
           NotFound = “Page not found”,
           OK,                // invalid
       }


Ex:
enum StatusCodes
{
     Ok,                      // 0
     NotFound = 404,
     Unauthorized             // 405
}
console.log(`${StatusCodes.NotFound} : ${StatusCodes[404]}`);

Ex:
     enum StatusCodes
     {
          A = 10,
          B = 20,
          C = A + B
     }
     console.log(`Addition=${StatusCodes.C}`);

Module & Namespace

11/09
======

Generic - Typesafe 

Note: Generic types will not allow operators to configure any expression. You have to handle

        by using functions. 

Syntax:
           function Name<T>(a:T, b:T) : T
           {
               return a + b; // invalid
               return sum(a,b); // valid
           }

Ex:
function Sum(a:any,b:any){
     return a + b;
}
function Calculate<T>(a:T, b:T):T 
{
     return Sum(a,b);
}
Calculate<number>(10, 20);

- Enum

                                                 Namespace
- Namespace is a collection of sub-namespaces and classes. 
- It allows to built large scale libraries to enable easy 
       a) reusability 
       b) extensibility 
       c) mantainability 
       d) testability 

Syntax:
       namespace  Name
       {
           // contracts
           // templates
           // components
           // functions 
       }
   - Namespace is imported into any project by using “/// <reference />” directive
Syntax:
           /// <reference  path=“./library” />
           import  aliasName = Namespace.Contract | Template | Component; 

   - You can’t directly compile namespace library, it requires a “outFile” flag.
           > tsc  -outFile   target.js    source.ts

1. Add a new folder by name “library”

           library
               |
               |_contracts
               |    |_ ProductContract.ts
               |_templates
               |    |_ProductTemplate.ts
               |_components
                   |_ProductComponent.ts
           app
               |_ index.ts

   Note: The outer namespace is default export, hence export is not defined for outer
            namespace.

 Contracts/ProductContract.ts

namespace Project 
{
     export namespace Contracts
     {
         export interface ProductContract
         {
             Name:string;
             Price:number;
             Qty:number;
             Total():number;
             Print():void;
         }
     }
}

Templates/ProductTemplate.ts

///<reference path="../contracts/ProductContract.ts" />

import ProductContract = Project.Contracts.ProductContract;

namespace Project 
{
    export namespace Templates
    {
         export abstract class ProductTemplate implements ProductContract
         {
              public Name:string = "";
              public Price:number = 0;
              public Qty:number = 0;
              public abstract Total():number;
              public abstract Print():void;
         }
    }
}

Components/ProductComponent.ts

///<reference path="../templates/ProductTemplate.ts" />

import ProductTemplate = Project.Templates.ProductTemplate;

namespace Project 
{
     export namespace Components 
     {
          export class ProductComponent extends ProductTemplate 
          {
              Name = "Samsung TV";
              Price = 45000;
              Qty = 2;
              Total(){
                return this.Qty * this.Price;
              }
              Print(){
                console.log(`Name=${this.Name}\nPrice=${this.Price}\nQty=${this.Qty}\nTotal=${this.Total()}`);
              }
          }
     }
}

App/index.ts

///<reference path="../library/components/ProductComponent.ts" />

 import ProductComponent = Project.Components.ProductComponent;

 let obj = new ProductComponent();
 obj.Print();

   app > tsc -outFile  index.js  index.ts
          > node index.js

Creating a React Typescript Application:

 > npm  create   vite@latest    app_name  
         framework    : react
       variant            : typescript 

 > change into app folder  
 > cd app_name
 > npm install

 13/09
 =======
 Vite React - TypeScript

Typescript File System for React:

           .tsx                components, hooks, slicers, store, reducers, main 
           .ts                    contracts, templates. [interface, abstract classes]
           .test.ts    ]        test files
           .spec.ts    ]        test files

Note: You have to import contracts or templates using “type” reference. 
         Components are imported using the same module system technique you used in JS.

Syntax:
               import  { component }   from  “path”;
               import  type { contract } from “path”;

State in TSX component:
   - State is generic type.
   - It is type safe member. 
   - You have to define the type for state while allocating memory.

   Syntax:
           const [get, set] = useState<T>();

   - If state is not initialized with type then it may return null. Hence while accessing you have
     to use null reference character “?”.

   - If state is initialized then null reference is not required.

Syntax:
           const [categories, setCategories] = useState<string[]>( [ ] );
           
           {   categories.map()   }

           const [categories, setCategories] = useState<string[]>( );
           
           {   categories?map()  }

Ex: Data Binding

  src/contract/product-contract.ts


export interface ProductContract
{
    id:number;
    title:string;
    price:number;
    description:string;
    image:string;
    rating: {rate:number, count:number},
    category:string;
}

  src/component/data-binding.tsx

import { useEffect, useState } from "react";
import type { ProductContract } from "../../contracts/product-contract";
import axios from "axios";

export function DataBinding(){

    const [categories, setCategories] = useState<string[]>();
    const [products, setProducts] = useState<ProductContract[]>();

    function GetCategories(){
        axios.get(`https://fakestoreapi.com/products/categories`)
        .then(response=>{
            setCategories(response.data);
        })
    }
    function GetProducts(){
        axios.get(`https://fakestoreapi.com/products`)
        .then(response=>{
            setProducts(response.data);
        })
    }

    useEffect(()=>{
        GetCategories();
        GetProducts();
    },[]);

    return(
        <div>
            <h2>Select Category</h2>
            <select>
               {
                    categories?.map(category=> <option key={category}>{category}</option>) 
               }
            </select>
            <div>
                <ul>
                    {
                        products?.map(product=> <li key={product.id}> <img src={product.image} width="50" height="50" /> {product.title} </li>)
                    }
                </ul>
            </div>
        </div>
    )
}

Event Binding
   - All event binding rules are same.
   - The event argument requires a data type configuration. 
   - “event” reference uses “any” as type.
   - Custom arguments require the relative types to define. 
   - You can use a local contract for configuring complex types. 

Syntax:
       function handleClick(e:any, param:contract)
       {
       }
   
       <button onClick={ (event) => handleClick(event, { key: value } ) }>

Ex: data-binding.tsx

import { useEffect, useState } from "react";
import type { ProductContract } from "../../contracts/product-contract";
import axios from "axios";

interface IProduct
{
    Name:string;
}

export function DataBinding(){

    const [categories, setCategories] = useState<string[]>();
    const [products, setProducts] = useState<ProductContract[]>();

    function GetCategories(){
        axios.get(`https://fakestoreapi.com/products/categories`)
        .then(response=>{
            setCategories(response.data);
        })
    }
    function GetProducts(){
        axios.get(`https://fakestoreapi.com/products`)
        .then(response=>{
            setProducts(response.data);
        })
    }

    useEffect(()=>{
        GetCategories();
        GetProducts();
    },[]);

    function handleClick(e:any, product:IProduct ){
        alert(`Clicked ${e.target.name} \n ${e.clientX} \n${product.Name} `);
    }

    return(
        <div>
            <h2>Select Category</h2>
            <button onClick={(event)=> handleClick(event, {Name:'TV'})}> Click Test</button>
            <select>
               {
                    categories?.map(category=> <option key={category}>{category}</option>) 
               }
            </select>
            <div>
                <ul>
                    {
                        products?.map(product=> <li key={product.id}> <img src={product.image} width="50" height="50" /> {product.title} </li>)
                    }
                </ul>
            </div>
        </div>
    )
}


15/09
=======

Controlled components in Typescript app:
   - A controlled component is managed by using “props”, which accept data from parent. 
   - Typescript requires the “props” to be an object type with strongly typed structure.

Syntax:
       export function ControlledComponent(props: Contract)
       {
                   // props.key
       }

Ex:
   src/contracts/INavbar.ts

export interface INavbar
{
    brand:string;
    navItems:string[];
}

   src/controlled-components/navbar.tsx

import type { INavbar } from "../contracts/Inavbar";

export function Navbar(props:INavbar)
{
     return (
        <nav className="border m-2 border-1 p-2 d-flex justify-content-between">
            <div className="fs-4 fw-bold">{props.brand}</div>
            <div>
                {
                    props.navItems.map(item=><span className="mx-4" key={item}>{item}</span>)
                }
            </div>
        </nav>
     )
}

   src/components/data-binding.tsx

import { useEffect, useState } from "react";
import type { ProductContract } from "../../contracts/product-contract";
import axios from "axios";
import { Navbar } from "../../controlled-components/navbar";

interface IProduct
{
    Name:string;
}

export function DataBinding(){

    const [categories, setCategories] = useState<string[]>();
    const [products, setProducts] = useState<ProductContract[]>();

    function GetCategories(){
        axios.get(`https://fakestoreapi.com/products/categories`)
        .then(response=>{
            setCategories(response.data);
        })
    }
    function GetProducts(){
        axios.get(`https://fakestoreapi.com/products`)
        .then(response=>{
            setProducts(response.data);
        })
    }

    useEffect(()=>{
        GetCategories();
        GetProducts();
    },[]);

    function handleClick(e:any, product:IProduct ){
        alert(`Clicked ${e.target.name} \n ${e.clientX} \n${product.Name} `);
    }

    return(
        <div>
            <Navbar brand="Shopping." navItems={['Home', 'Shop', 'Pages', 'Blog', 'Docs']} />
            <h2>Select Category</h2>
            <button onClick={(event)=> handleClick(event, {Name:'TV'})}> Click Test</button>
            <select>
               {
                    categories?.map(category=> <option key={category}>{category}</option>) 
               }
            </select>
            <div>
                <ul>
                    {
                        products?.map(product=> <li key={product.id}> <img src={product.image} width="50" height="50" /> {product.title} </li>)
                    }
                </ul>
            </div>
        </div>
    )
}

React Fullstack Application
   - A fullstack application requires

               a) database 
               b) server scripts with API
               c) middleware 
               d) client side library / framework 
   - MERN stack
               M                MongoDB
               E                Express JS
               R                React
               N                Node JS

                                                           Next JS
 - Next JS is a React Framework.
 - Framework allows to build application and control the application flow.
 - It provides server side actions with middleware support. 

Features:
   1. Basic Page Routing
   2. Nested Routes
   3. Dynamic Routes
   4. Optimization
   5. Server Side Components 
   6. Modular 
   7. Fluid Interactions 
   8. Supports CSS framework like Tailwind, Sass etc.
   9. Pre Rendering [ SSR]    
   10. Static Site Generation [ SSG ]
   11. Code Splitting & Automatic Bundling 
   12. Faster Refresh 
   13. SEO & Meta Data
   14. Deployment Ready Environment 

React Next JS App:
   - Open any location on your PC in terminal 
   - Run the following command
   
           > npx   create-next-app@latest     [app_name_optional]

✔ Would you like to use TypeScript? … No / Yes
✔ Which linter would you like to use? › ESLint
✔ Would you like to use Tailwind CSS? … No / Yes
✔ Would you like your code inside a `src/` directory? … No / Yes
✔ Would you like to use App Router? (recommended) … No / Yes
✔ Would you like to use Turbopack? (recommended) … No / Yes
✔ Would you like to customize the import alias (`@/*` by default)? … No / Yes

           > npm run dev

   - Default routes are supported with file system architecture
   - Application automatically can start with a file by name “page.tsx / page.js / page.jsx”
   - Routing is configured automatically if files are defined in  “app” or “pages” folder.

1. Add new folders into “app”
           products/page.tsx
                   export default function ProductHome()
                   {
                     return (<div> </div>);
                   }
           employees/page.tsx
                   export default function EmployeeHome()
                   {
                      return (<div> </div>);
                   }

2. You can navigate using “next/link” => Add in  src/page.tsx 
           <Link href=“/products”> Product Home </Link>